<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>src/di.html - Protoboard</title>

  <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">

  <link rel="stylesheet" href="../assets/css/class.css">
  <link rel="stylesheet" href="../assets/css/events.css">
  <link rel="stylesheet" href="../assets/css/index.css">
  <link rel="stylesheet" href="../assets/css/main.css">
  <link rel="stylesheet" href="../assets/css/method.css">
  <link rel="stylesheet" href="../assets/css/prettyprint.css">
  <link rel="stylesheet" href="../assets/css/props.css">
  <link rel="stylesheet" href="../assets/css/sidebar.css">
  <style>
    @import url(http://fonts.googleapis.com/css?family=Roboto);
    @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono);

    body {
      background-color: #222;
      color: white;
      display: flex;
      flex-direction: column;
      font-family: 'Roboto', Helvetica, Arial, sans-serif;
      font-size: smaller;
      line-height: 3ex;
      margin: 0;
      height: 100vh;
    }

    .description code {
      color: #F6F080;
      background-color: #444;
      border-radius: 4px;
      padding: 2px 4px;
    }

    h1, h2 {
      margin: 5px 0;
    }

    a, a:visited {
      color: gold;
      text-decoration: none;
    }

    a.external {
      color: darkorange;
    }

    a:hover {
      text-decoration: underline;
    }

    pre,
    code,
    a.crosslink {
      font-family: 'Ubuntu Mono', monospace;
    }

    .prettyprint code {
      background-color: transparent;
      border-radius: 0;
      padding: 0;
    }

    code .keyword {
      color: #808080;
    }

    div.content {
      max-width: 50em;
    }

    section.collapsible > header {
      background-color: #004000;
      padding: 5px 20px;
      cursor: pointer;
      -webkit-user-select: none;
      transition: padding .2s;
      position: relative;
    }

    section.collapsible > header h2 {
      font-size: 1.2em;
    }

    section.collapsible > header::after {
      background-image: -webkit-linear-gradient(270deg, #004000, transparent);
      content: '';
      display: block;
      height: 10px;
      position: absolute;
      width: 100%;
      left: 0;
      bottom: -10px;
    }

    section.collapsible.collapsed > header {
      padding-bottom: 5px;
    }

    section.collapsible > div {
      overflow: hidden;
      transition: height .2s;
    }

    footer {
      border: 2px solid #004000;
      padding: 15px;
      -webkit-margin-before: 20px;
    }

    header.tutorial {
      color: #008000;
    }
  </style>
  <style>
    header.main-header h1 a {
      color: #008000;
    }
  </style>
</head>
<body>
  <header class="main-header">
    <div>
      <h1><a href="../index.html">Protoboard</a></h1>
      <span class="main-subtitle">v 0.1.0</span>
    </div>
    <a href="https://github.com/garysoed/protoboard">GitHub</a>
  </header>
  <section class="main-content">
    <section class="main-sidebar"><div class="sidebar">
    <section class="collapsible ">
      <header>
        <h2>tutorial</h2>
      </header>
      <div>
        <ul>
          <li class="">
            <a href="../classes/1 Overview.html">1 Overview</a>
          </li>
          <li class="">
            <a href="../classes/2 Prerequisites.html">2 Prerequisites</a>
          </li>
          <li class="">
            <a href="../classes/3 Basic Usage.html">3 Basic Usage</a>
          </li>
          <li class="">
            <a href="../classes/4 Customizing Components.html">4 Customizing Components</a>
          </li>
        </ul>
      </div>
    </section>
    <section class="collapsible ">
      <header>
        <h2>api</h2>
      </header>
      <div>
        <ul>
          <li class="">
            <a href="../classes/ability.Abilities.html">ability.Abilities</a>
          </li>
          <li class="">
            <a href="../classes/ability.Abilities.Builder.html">ability.Abilities.Builder</a>
          </li>
          <li class="">
            <a href="../classes/ability.Ability.html">ability.Ability</a>
          </li>
          <li class="">
            <a href="../classes/ability.Droppable.html">ability.Droppable</a>
          </li>
          <li class="">
            <a href="../classes/ability.Helpable.html">ability.Helpable</a>
          </li>
          <li class="">
            <a href="../classes/ability.Pickable.html">ability.Pickable</a>
          </li>
          <li class="">
            <a href="../classes/ability.Shuffleable.html">ability.Shuffleable</a>
          </li>
          <li class="">
            <a href="../classes/ability.Toggleable.html">ability.Toggleable</a>
          </li>
          <li class="">
            <a href="../classes/Check.html">Check</a>
          </li>
          <li class="">
            <a href="../classes/component.Card.html">component.Card</a>
          </li>
          <li class="">
            <a href="../classes/component.Component.html">component.Component</a>
          </li>
          <li class="">
            <a href="../classes/component.Token.html">component.Token</a>
          </li>
          <li class="">
            <a href="../classes/DI.BindingTree.html">DI.BindingTree</a>
          </li>
          <li class="">
            <a href="../classes/DI.Provider.html">DI.Provider</a>
          </li>
          <li class="">
            <a href="../classes/DI.Scope.html">DI.Scope</a>
          </li>
          <li class="">
            <a href="../classes/Events.html">Events</a>
          </li>
          <li class="">
            <a href="../classes/Events.Action.html">Events.Action</a>
          </li>
          <li class="">
            <a href="../classes/HammerWrapper.html">HammerWrapper</a>
          </li>
          <li class="">
            <a href="../classes/PbElement.html">PbElement</a>
          </li>
          <li class="">
            <a href="../classes/region.Bag.html">region.Bag</a>
          </li>
          <li class="">
            <a href="../classes/region.Bag.RandomPickable.html">region.Bag.RandomPickable</a>
          </li>
          <li class="">
            <a href="../classes/region.Deck.html">region.Deck</a>
          </li>
          <li class="">
            <a href="../classes/region.Hand.html">region.Hand</a>
          </li>
          <li class="">
            <a href="../classes/region.Hand.ReorderableDroppable.html">region.Hand.ReorderableDroppable</a>
          </li>
          <li class="">
            <a href="../classes/region.Rect.html">region.Rect</a>
          </li>
          <li class="">
            <a href="../classes/region.Rect.FlexDroppable.html">region.Rect.FlexDroppable</a>
          </li>
          <li class="">
            <a href="../classes/region.Region.html">region.Region</a>
          </li>
          <li class="">
            <a href="../classes/service.Move.html">service.Move</a>
          </li>
          <li class="">
            <a href="../classes/service.Preview.html">service.Preview</a>
          </li>
          <li class="">
            <a href="../classes/service.Registry.html">service.Registry</a>
          </li>
          <li class="">
            <a href="../classes/surface.RectGrid.html">surface.RectGrid</a>
          </li>
          <li class="">
            <a href="../classes/trigger.Click.html">trigger.Click</a>
          </li>
          <li class="">
            <a href="../classes/trigger.DoubleClick.html">trigger.DoubleClick</a>
          </li>
          <li class="">
            <a href="../classes/trigger.Key.html">trigger.Key</a>
          </li>
          <li class="">
            <a href="../classes/trigger.Key.Service.html">trigger.Key.Service</a>
          </li>
          <li class="">
            <a href="../classes/trigger.Trigger.html">trigger.Trigger</a>
          </li>
          <li class="">
            <a href="../classes/ui.Preview.html">ui.Preview</a>
          </li>
          <li class="">
            <a href="../classes/ui.Previewer.html">ui.Previewer</a>
          </li>
          <li class="">
            <a href="../classes/ui.Template.html">ui.Template</a>
          </li>
          <li class="">
            <a href="../classes/Utils.html">Utils</a>
          </li>
        </ul>
      </div>
    </section>
</div>


</section>
    <section class="main-main"><h4>src/di.html</h4>

<pre class="code prettyprint linenums">
&lt;base href=&quot;.&quot;&gt;
&lt;script&gt;
(() =&gt; {

// Private symbols.
const __function__ = Symbol();
const __localBindings__ = Symbol(&#x27;localBindings&#x27;);
const __localScope__ = Symbol(&#x27;localScope&#x27;);
const __name__ = Symbol();
const __parentScope__ = Symbol(&#x27;parentScope&#x27;);
const __resolvedValues__ = Symbol();
const __values__ = Symbol(&#x27;values&#x27;);

const __get__ = Symbol(&#x27;get&#x27;);

const FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
const SEPARATOR = &#x27;_&#x27;;

class Provider {

  /**
   * @class DI.Provider
   * @constructor
   * @param {Function} fn The function to run. The function&#x27;s arguments will be bound based on
   *    their names.
   * @param {string} [name=null] Reference name of the provider. This is used for detecting cyclic
   *    dependencies.
   */
  constructor(fn, localScope, name = null) {
    this[__function__] = fn;
    this[__localScope__] = localScope;
    this[__name__] = name;
    this[__resolvedValues__] = new Map();
  }

  /**
   * Resolves the provider. Resolved values are cached per scope.
   *
   * @method resolve
   * @param {DI.Scope} scope The scope to resolve the value in.
   * @return {Object} The resolved value for the given scope.
   */
  resolve(scope) {
    if (!this[__resolvedValues__].has(scope)) {
      let argsString = this[__function__].toString().match(FN_ARGS)[1];
      let args = argsString ? argsString.split(&#x27;,&#x27;) : [];

      let resolvedArgs = args.map(arg =&gt; {
        arg = arg.trim();
        let optional = false;

        if (arg.substring(0, 4) === &#x27;opt_&#x27;) {
          arg = arg.substring(4);
          optional = true;
        }

        // TODO(gs): Handle cyclic dependency.
        let value;

        try {
          // Check the local scope first.
          value = this[__localScope__][__get__](arg, scope);

          if (value === undefined) {
            // If value cannot be resolved in the local scope, check the given scope.
            value = scope[__get__](arg, scope);
          }

          if (value === undefined) {
            // If value cannot be resolved in the local scope, check the global bindings.
            value = getGlobal(arg, scope);
          }
        } catch (e) {
          // TODO(gs): Make a shared method.
          if (this[__name__]) {
            throw &#x60;${e}\n\twhile providing ${this[__name__]}&#x60;;
          } else {
            throw &#x60;${e}\n\twhile running expression&#x60;;
          }
        }

        if (value === undefined) {
          if (optional) {
            return undefined;
          } else if (this[__name__]) {
            throw &#x60;Cannot find ${arg} while providing ${this[__name__]}&#x60;;
          } else {
            throw &#x60;Cannot find ${arg} while running expression&#x60;;
          }
        }

        return value;
      });

      let value;

      try {
        value = this[__function__].apply(null, resolvedArgs);
      } catch (e) {
        if (this[__name__]) {
          throw &#x60;Uncaught exception ${e}\n\twhile running provider ${this[__name__]}&#x60;;
        } else {
          throw &#x60;Uncaught exception ${e}\n\twhile running expression&#x60;;
        }
      }

      if (value === undefined &amp;&amp; this[__name__]) {
        console.warn(&#x60;Value of ${this[__name__]} is undefined&#x60;);
      }

      this[__resolvedValues__].set(scope, value);
    }

    return this[__resolvedValues__].get(scope);
  }
}

class BindingTree {

  /**
   * Represents a tree of bound values keyed by binding key.
   * @class DI.BindingTree
   * @constructor
   */
  constructor() {
    this[__values__] = new Map();
  }

  /**
   * Adds the given key and value to the tree. The tree will try to bind using the last segment of
   * the key. If this causes a conflict, it will create a subtree.
   *
   * @method add
   * @param {string} key The key to bind the value to.
   * @param {Object} value The value to be bound.
   * @param {number} [depth=0] The depth of the key to use as binding key. This should not be
   *    called from outside the class.
   */
  add(key, value, depth = 0) {
    let segments = key.split(SEPARATOR);
    let bindingKey = segments[segments.length - 1 - depth];

    if (!this[__values__].has(bindingKey)) {
      this[__values__].set(bindingKey, {
        key: key,
        value: value
      });
    } else {
      // There is already a value corresponding to this key
      let existingValue = this[__values__].get(bindingKey);
      if (existingValue.key === key) {
        throw &#x60;Key ${key} is already bound&#x60;;
      }

      let newTree = new BindingTree();
      this[__values__].set(bindingKey, newTree);
      newTree.add(existingValue.key, existingValue.value, depth + 1);
      newTree.add(key, value, depth + 1);
    }
  }

  /**
   * Returns the value corresponding to the given key.
   *
   * @param {string} key Key of the value to return.
   * @param {number} [depth=0] The depth of the key to use as binding key. This should not be
   *    called from outside the class.
   * @return {any} The bound value, or undefined if the value cannot be found, or if the key has
   *    collision but collision cannot be resolved.
   */
  get(key, depth = 0) {
    let segments = key.split(SEPARATOR);
    let bindingKey = segments[segments.length - 1 - depth];

    if (bindingKey === undefined) {
      return undefined;
    }

    if (!this[__values__].has(bindingKey)) {
      return undefined;
    }

    let value = this[__values__].get(bindingKey);
    if (value instanceof BindingTree) {
      return value.get(key, depth + 1);
    } else {
      return value.value;
    }
  }
}

class Scope {
  /**
   * Scope containing local bindings.
   *
   * @class DI.Scope
   * @constructor
   * @param {DI.Scope} [parentScope=null] The parent scope.
   */
  constructor(parentScope = null) {
    this[__localBindings__] = new BindingTree();
    this[__parentScope__] = parentScope;
  }

  [__get__](key, scope) {
    let provider = this[__localBindings__].get(key);
    if (provider === undefined) {
      if (this[__parentScope__]) {
        return this[__parentScope__][__get__](key, scope);
      } else {
        return undefined;
      }
    } else {
      return provider.resolve(scope);
    }
  }

  /**
   * Creates a new child scope with the given value bound to the given key in its local binding.
   *
   * @method with
   * @param {string} key The key to bound the value to.
   * @param {Function} fn The function to run. The function&#x27;s arguments will be bound based on
   *    their names.
   * @return {DI.Scope} The newly created child scope.
   */
  with(key, value) {
    let childScope = new Scope(this);
    childScope[__localBindings__].add(key, new Provider(value, this, key));
    return childScope;
  }

  constant(key, value) {
    return this.with(key, () =&gt; value);
  }

  /**
   * Globally binds the given value to the given key.
   *
   * @method bind
   * @param {string} key The key to bound the value to.
   * @param {Function} fn The function to run. The function&#x27;s arguments will be bound based on
   *    their names.
   */
  bind(key, value) {
    bindings.add(key, new Provider(value, this, key));
    return this;
  }

  /**
   * Returns the provider bound to the given key and resolve it in this scope. This will first check
   * for the local bindings, then its ancestors. If no binding is found in the ancestral path, this
   * will check for the global bindings.
   *
   * @method get
   * @param {string} key Key whose bound value should be returned.
   * @return {any} The value bound to the given key, or undefined if no values can be found.
   */
  get(key) {
    let value = this[__get__](key);
    if (value === undefined) {
      return getGlobal(key, this);
    } else {
      return value;
    }
  }

  /**
   * Runs the given function after injecting any dependencies.
   *
   * @method run
   * @param {Function} fn The function to run. The function&#x27;s arguments will be bound based on
   *    their names.
   */
  run(fn) {
    new Provider(fn, this).resolve(this);
  }
}

const bindings = new BindingTree();

function getGlobal(key, scope) {
  let globalProvider = bindings.get(key);
  if (globalProvider === undefined) {
    return undefined;
  } else {
    return globalProvider.resolve(scope);
  }
}

const DI = new Scope();
window[&#x27;DI&#x27;] = DI;

if (window[&#x27;TEST_MODE&#x27;]) {
  DI.Scope = Scope;
  DI.BindingTree = BindingTree;
  DI.Provider = Provider;
  DI.bindings = bindings;
}

})();
&lt;/script&gt;
</pre>

</section>
  </section>
</body>
  <script src="../assets/vendor/prettify/prettify-min.js"></script>
  <script>prettyPrint();</script>
  <script>
    var els = document.querySelectorAll('section.collapsible');
    for (var i = 0; i < els.length; i++) {
      var section = els.item(i);
      var content = section.querySelector('div');
      var header = section.querySelector('header');
      var height = content.clientHeight + 'px';
      header.addEventListener('click', function(section, content, contentHeight) {
        section.classList.toggle('collapsed');
        content.style.height = section.classList.contains('collapsed') ? '0' : contentHeight;
      }.bind(header, section, content, height));
      content.style.height = height;
    }
  </script>
</html>
