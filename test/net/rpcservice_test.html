<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>net.RpcService Unit Tests</title>

  <link rel="import" href="net/inmemoryio.html">
  <link rel="import" href="net/rpcservice.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
<script>
DIJS
.run(require => {
  const _ = require('spies.Spies');
  const Events = require('pb.Events');
  const expect = require('chai.expect');
  const InMemoryIO = require('pb.net.InMemoryIO');
  const Rpc = require('pb.net.RpcService.__ctor__');
  const t = require('pb.t');

  describe('net.RpcService', () => {
    let io;
    let listenHandler;
    let rpc;

    beforeEach(() => {
      io = new InMemoryIO();
      rpc = new Rpc(io);
    });

    it('should trigger updates in reaction to changes triggered by IO', () => {
      let aHandler = _.spiedFunction();
      let abHandler = _.spiedFunction();

      Events.of(rpc, this)
          .on('jquery', '/a', aHandler)
          .on('jquery', '/a/b', abHandler);

      io.set('/a/b', 1);

      expect(aHandler).called().at.least(1);
      expect(abHandler).called().at.least(1);
    });

    describe('__triggerUpdates__', () => {
      it('should trigger paths and their ancestors', () => {
        let aHandler = _.spiedFunction();
        let abHandler = _.spiedFunction();

        Events.of(rpc, this)
            .on('jquery', '/a', aHandler)
            .on('jquery', '/a/b', abHandler);

        t.getPrivateMethod(rpc, 'triggerUpdates')('/a/b');

        expect(aHandler).called().at.least(1);
        expect(abHandler).called().at.least(1);
      });
      it('should not trigger paths that are not the ancestor path', () => {
        let handler = _.spiedFunction();
        Events.of(rpc, this).on('jquery', '/c', handler);

        t.getPrivateMethod(rpc, 'triggerUpdates')('/a/b');

        expect(handler).called().to.equal(0);
      });
    });

    describe('add', () => {
      beforeEach(() => {
        return io.set('/a/b', { $index: true, keys: ['0'] });
      });

      it('should resolve with the new ID', () => {
        return rpc.add('/a/b').then(newId => {
          expect(newId).to.equal('1');
        });
      });
      it('should backfill the ancestors', () => {
        return rpc.add('/a/b')
            .then(() => Promise.all([
              io.get('/a'),
              io.get('/a/b')
            ]))
            .then(values => {
              let [a, ab] = values;
              expect(a.$index).to.be.true;
              expect(a.keys).to.eql(['b']);

              expect(ab.$index).to.be.true;
              expect(ab.keys).to.eql(['0', '1']);
            });
      });
      it('should replace existing non object entry', () => {
        return rpc.set('/a/b', 1)
            .then(() => rpc.add('/a/b'))
            .then(() => io.get('/a/b'))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql(['0']);
            });
      });
      it('should initialize the entry with empty object', () => {
        return rpc.add('/a/b')
            .then(newId => rpc.get(`/a/b/${newId}`))
            .then(value => {
              expect(value).to.eql({});
            });
      });
    });

    describe('remove', () => {
      let removedPath;

      beforeEach(() => {
        return rpc.add('/a/b')
            .then(newId => {
              removedPath = `/a/b/${newId}`;
            });
      });

      it('should delete the entry', () => {
        return rpc.remove(removedPath)
            .then(() => io.get(removedPath))
            .then(value => {
              expect(value).to.be.null;
            });
      });
      it('should update the parent index', () => {
        return rpc.add('/a/b')
            .then(() => rpc.remove(removedPath))
            .then(() => io.get('/a/b'))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql(['1']);
            });
      });
      it('should propagate removal all the way to the root', () => {
        return rpc.remove(removedPath)
            .then(() => Promise.all([
              io.get('/a'),
              io.get('/a/b')
            ]))
            .then(values => {
              let [a, ab] = values;
              expect(a).to.be.null;
              expect(ab).to.be.null;
            });
      });
    });

    describe('get', () => {
      const PATH = '/a/b';

      it('should resolve primitive value', () => {
        return io.set(PATH, 1)
            .then(() => rpc.get(PATH))
            .then(value => {
              expect(value).to.equal(1);
            });
      });
      it('should resolve object value and their sub objects', () => {
        let expectedAb = {
          c: {
            d: 3
          }
        };

        return Promise.all([
          io.set(PATH, { $index: true, keys: ['c'] }),
          io.set(`${PATH}/c`, { $index: true, keys: ['d'] }),
          io.set(`${PATH}/c/d`, 3)
        ])
        .then(() => Promise.all([
          rpc.get(PATH),
          rpc.get(`${PATH}/c`),
          rpc.get(`${PATH}/c/d`)
        ]))
        .then(values => {
          let [ab, abc, abcd] = values;

          expect(ab).to.eql(expectedAb);
          expect(abc).to.eql(expectedAb.c);
          expect(abcd).to.eql(expectedAb.c.d);
        });
      });
      it('should return null if the value does not exist', () => {
        return rpc.get(PATH)
            .then(value => {
              expect(value).to.be.null;
            });
      });
    });

    describe('set', () => {
      const PATH = '/a/b';

      it('should set primitive value', () => {
        return rpc.set(PATH, 1)
            .then(() => io.get(PATH))
            .then(value => {
              expect(value).to.equal(1);
            });
      });
      it('should set object value and their sub objects', () => {
        return rpc.set(PATH, {
              c1: 1,
              c2: {
                d: 2
              }
            })
            .then(() => Promise.all([
                io.get(`${PATH}/c1`),
                io.get(`${PATH}/c2`),
                io.get(`${PATH}/c2/d`)
            ]))
            .then(values => {
              let [c1, c2, c2d] = values;

              expect(c1).to.eql(1);
              expect(c2.$index).to.be.true;
              expect(c2.keys).to.eql([ 'd' ]);
              expect(c2d).to.eql(2);
            });
      });
      it('should handle objects with no keys', () => {
        return rpc.set(PATH, {})
            .then(() => io.get(PATH))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql([]);
            });
      });
      it('should handle arrays', () => {
        return rpc.set(PATH, [])
            .then(() => io.get(PATH))
            .then(value => {
              expect(value).to.eql([]);
            });
      });
      it('should backfill the ancestors', () => {
        return rpc.set(PATH, 1)
            .then(() => io.get('/a'))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql(['b']);
            });
      });
      it('should replace non index ancestors with index', () => {
        return rpc.set(PATH, 1)
            .then(() => rpc.set(`${PATH}/c`, 2))
            .then(() => io.get(`${PATH}`))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql(['c']);
            });
      });
      it('should update the indexes of the ancestors', () => {
        return rpc.set(PATH, 1)
            .then(() => rpc.set(`/a/c`, 2))
            .then(() => io.get(`/a`))
            .then(value => {
              expect(value.$index).to.be.true;
              expect(value.keys).to.eql(['b', 'c']);
            });
      });
      it('should not add duplicate keys', () => {
        return rpc.set(PATH, 1)
            .then(() => rpc.set(PATH, 2))
            .then(() => io.get('/a'))
            .then(value => {
              expect(value.keys).to.eql(['b']);
            });
      });
    });

    afterEach(() => {
      _.reset();
    });
  });
});
</script>
</body>
