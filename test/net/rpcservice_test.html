<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>net.RpcService Unit Tests</title>

  <link rel="import" href="net/inmemoryio.html">
  <link rel="import" href="net/rpcservice.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
<script>
DIJS
.run(require => {
  const Events = require('pb.Events');
  const InMemoryIO = require('pb.net.InMemoryIO');
  const j = require('jasmine');
  const Rpc = require('pb.net.RpcService.__ctor__');
  const t = require('pb.t');

  describe('net.RpcService', () => {
    let io;
    let listenHandler;
    let rpc;

    beforeEach(() => {
      io = new InMemoryIO();
      rpc = new Rpc(io);
    });

    it('should trigger updates in reaction to changes triggered by IO', () => {
      let aHandler = j.createSpy('aHandler');
      let abHandler = j.createSpy('abHandler');

      Events.of(rpc, this)
          .on('jquery', '/a', aHandler)
          .on('jquery', '/a/b', abHandler);

      io.set('/a/b', 1);

      expect(aHandler).toHaveBeenCalled();
      expect(abHandler).toHaveBeenCalled();
    });

    describe('__triggerUpdates__', () => {
      it('should trigger paths and their ancestors', () => {
        let aHandler = j.createSpy('aHandler');
        let abHandler = j.createSpy('abHandler');

        Events.of(rpc, this)
            .on('jquery', '/a', aHandler)
            .on('jquery', '/a/b', abHandler);

        t.getPrivateMethod(rpc, 'triggerUpdates')('/a/b');

        expect(aHandler).toHaveBeenCalled();
        expect(abHandler).toHaveBeenCalled();
      });
      it('should not trigger paths that are not the ancestor path', () => {
        let handler = j.createSpy('handler');
        Events.of(rpc, this).on('jquery', '/c', handler);

        t.getPrivateMethod(rpc, 'triggerUpdates')('/a/b');

        expect(handler).not.toHaveBeenCalled();
      });
    });

    describe('add', () => {
      beforeEach(done => {
        io.set('/a/b', { $index: true, keys: ['0'] })
            .then(done);
      });

      it('should resolve with the new ID', done => {
        rpc.add('/a/b')
            .then(newId => {
              expect(newId).toEqual('1');
            })
            .then(done);
      });
      it('should backfill the ancestors', done => {
        rpc.add('/a/b')
            .then(() => Promise.all([
              io.get('/a'),
              io.get('/a/b')
            ]))
            .then(values => {
              let [a, ab] = values;
              expect(a.$index).toEqual(true);
              expect(a.keys).toEqual(['b']);

              expect(ab.$index).toEqual(true);
              expect(ab.keys).toEqual(['0', '1']);
            })
            .then(done);
      });
      it('should replace existing non object entry', done => {
        rpc.set('/a/b', 1)
            .then(() => rpc.add('/a/b'))
            .then(() => io.get('/a/b'))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual(['0']);
            })
            .then(done);
      });
      it('should initialize the entry with empty object', done => {
        rpc.add('/a/b')
            .then(newId => rpc.get(`/a/b/${newId}`))
            .then(value => {
              expect(value).toEqual({});
            })
            .then(done);
      });
    });

    describe('remove', () => {
      let removedPath;

      beforeEach(done => {
        rpc.add('/a/b')
            .then(newId => {
              removedPath = `/a/b/${newId}`;
            })
            .then(done);
      });

      it('should delete the entry', done => {
        rpc.remove(removedPath)
            .then(() => io.get(removedPath))
            .then(value => {
              expect(value).toEqual(null);
            })
            .then(done);
      });
      it('should update the parent index', done => {
        rpc.add('/a/b')
            .then(() => rpc.remove(removedPath))
            .then(() => io.get('/a/b'))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual(['1']);
            })
            .then(done);
      });
      it('should propagate removal all the way to the root', done => {
        rpc.remove(removedPath)
            .then(() => Promise.all([
              io.get('/a'),
              io.get('/a/b')
            ]))
            .then(values => {
              let [a, ab] = values;
              expect(a).toEqual(null);
              expect(ab).toEqual(null);
            })
            .then(done);
      });
    });

    describe('get', () => {
      const PATH = '/a/b';

      it('should resolve primitive value', done => {
        io.set(PATH, 1)
            .then(() => rpc.get(PATH))
            .then(value => {
              expect(value).toEqual(1);
            })
            .then(done);
      });
      it('should resolve object value and their sub objects', done => {
        let expectedAb = {
          c: {
            d: 3
          }
        };

        Promise.all([
          io.set(PATH, { $index: true, keys: ['c'] }),
          io.set(`${PATH}/c`, { $index: true, keys: ['d'] }),
          io.set(`${PATH}/c/d`, 3)
        ])
        .then(() => Promise.all([
          rpc.get(PATH),
          rpc.get(`${PATH}/c`),
          rpc.get(`${PATH}/c/d`)
        ]))
        .then(values => {
          let [ab, abc, abcd] = values;

          expect(ab).toEqual(expectedAb);
          expect(abc).toEqual(expectedAb.c);
          expect(abcd).toEqual(expectedAb.c.d);
        })
        .then(done);
      });
      it('should return null if the value does not exist', done => {
        rpc.get(PATH)
            .then(value => {
              expect(value).toEqual(null);
            })
            .then(done);
      });
    });

    describe('set', () => {
      const PATH = '/a/b';

      it('should set primitive value', done => {
        rpc.set(PATH, 1)
            .then(() => io.get(PATH))
            .then(value => {
              expect(value).toEqual(1);
            })
            .then(done);
      });
      it('should set object value and their sub objects', done => {
        rpc.set(PATH, {
              c1: 1,
              c2: {
                d: 2
              }
            })
            .then(() => Promise.all([
                io.get(`${PATH}/c1`),
                io.get(`${PATH}/c2`),
                io.get(`${PATH}/c2/d`)
            ]))
            .then(values => {
              let [c1, c2, c2d] = values;

              expect(c1).toEqual(1);
              expect(c2.$index).toEqual(true);
              expect(c2.keys).toEqual([ 'd' ]);
              expect(c2d).toEqual(2);
            })
            .then(done);
      });
      it('should handle objects with no keys', done => {
        rpc.set(PATH, {})
            .then(() => io.get(PATH))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual([]);
            })
            .then(done);
      });
      it('should handle arrays', done => {
        rpc.set(PATH, [])
            .then(() => io.get(PATH))
            .then(value => {
              expect(value).toEqual([]);
            })
            .then(done);
      });
      it('should backfill the ancestors', done => {
        rpc.set(PATH, 1)
            .then(() => io.get('/a'))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual(['b']);
            })
            .then(done);
      });
      it('should replace non index ancestors with index', done => {
        rpc.set(PATH, 1)
            .then(() => rpc.set(`${PATH}/c`, 2))
            .then(() => io.get(`${PATH}`))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual(['c']);
            })
            .then(done);
      });
      it('should update the indexes of the ancestors', done => {
        rpc.set(PATH, 1)
            .then(() => rpc.set(`/a/c`, 2))
            .then(() => io.get(`/a`))
            .then(value => {
              expect(value.$index).toEqual(true);
              expect(value.keys).toEqual(['b', 'c']);
            }).then(done);
      });
      it('should not add duplicate keys', done => {
        rpc.set(PATH, 1)
            .then(() => rpc.set(PATH, 2))
            .then(() => io.get('/a'))
            .then(value => {
              expect(value.keys).toEqual(['b']);
            })
            .then(done);
      });
    });
  });
});
</script>
</body>
