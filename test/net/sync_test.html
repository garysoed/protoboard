<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>net.Sync Unit Tests</title>

  <link rel="import" href="net/sync.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
<script>
DIJS
.constant('pb.net.RpcService', {
  add: () => {},
  get: () => {},
  remove: () => {},
  set: () => {}
})
.run(require => {

  const $ = require('pb.JQuery');
  const Events = require('pb.Events');
  const j = require('jasmine');
  const Rpc = require('pb.net.RpcService');
  const Sync = require('pb.net.Sync');

  describe('net.Sync', () => {
    const ID = 'id';
    const PREFIX = '/prefix';

    let sync;

    beforeEach(() => {
      sync = new Sync(ID, PREFIX);
    });

    it('should listen to changes from Rpc', () => {
      let handler = j.createSpy('handler');
      Events.of(sync, sync).on('jquery', Sync.Events.UPDATED, handler);

      $(Rpc).trigger(`${PREFIX}/${ID}`);
      expect(handler).toHaveBeenCalled();
    });

    describe('add', () => {
      it('should return the newly added sync object', () => {
        spyOn(Rpc, 'add').and.returnValue(Promise.resolve('newId'));

        return sync.add()
            .then(newSync => {
              expect(newSync.id).toEqual('newId');
              expect(newSync.path).toEqual(`${PREFIX}/${ID}/newId`);

              expect(Rpc.add).toHaveBeenCalledWith(`${PREFIX}/${ID}`);
            });
      });
    });

    describe('remove', () => {
      it('should remove the current object', () => {
        spyOn(Rpc, 'remove').and.returnValue(Promise.resolve());

        return sync.remove()
            .then(() => {
              expect(Rpc.remove).toHaveBeenCalledWith(`${PREFIX}/${ID}`);
            });
      });
    });

    describe('get', () => {
      it('should retrieve the value from Rpc', () => {
        spyOn(Rpc, 'get').and.returnValue(Promise.resolve(1));

        return sync.get()
            .then(value => {
              expect(value).toEqual(1);
            });
      });
    });

    describe('set', () => {
      it('should set the value and returns itself', () => {
        spyOn(Rpc, 'set').and.returnValue(Promise.resolve());

        return sync.set('data')
            .then(returnedSync => {
              expect(Rpc.set).toHaveBeenCalledWith(`${PREFIX}/${ID}`, 'data');
              expect(returnedSync).toEqual(sync);
            });
      });
    });

    describe('sync', () => {
      it('should return a sync object with the given subpath', () => {
        let subpath = 'c/d';

        let subSync = sync.sync(subpath);
        expect(subSync.id).toEqual('d');
        expect(subSync.path).toEqual(`${sync.path}/${subpath}`);
      });
    });
  });
});
</script>
</body>
