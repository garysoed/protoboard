<!DOCTYPE html>
<html>
<head>
  <base href="../..">
  <title>Rect Unit Tests</title>
  <link rel="import" href="out/testbase.html">

  <link rel="import" href="out/di.html">
  <link rel="import" href="out/region/rect.html">
  <link rel="import" href="out/service/dragdrop.html">
  <link rel="import" href="out/utils.html">
</head>
<body>
  <pb-r-rect></pb-r-rect>

  <script>
  DI
      .constant('doc', document.currentScript.ownerDocument)
      .run((expect, _, doc, DragDrop, Rect, Utils) => {

  let SmartDroppable = Rect.SmartDroppable;

  let __onDomMutation__ = Utils.getSymbol(SmartDroppable.prototype, 'onDomMutation');

  describe('Rect', () => {
    describe('$SmartDroppable', () => {
      let el;
      let smartDroppable;

      let __mutationObserver__;

      beforeEach(done => {
        el = doc.createElement('div');
        smartDroppable = new SmartDroppable(true);
        __mutationObserver__ = Utils.getSymbol(smartDroppable, 'mutationObserver');
        done();
      });

      describe('#trigger', () => {
        it('should remove the pb-over class, append the last dragged element, and position it correctly', () => {
          let lastDraggedEl = doc.createElement('div');
          lastDraggedEl.attachedCallback = _.spiedFunction();
          _.spy(lastDraggedEl, 'getBoundingClientRect').overrideReturn({
            left: 56,
            top: 78
          });

          DragDrop.dragStart(lastDraggedEl, 12 /** offsetX */, 34 /** offsetY */);
          _.spy(DragDrop, 'dragEnd');

          el.classList.add('pb-over');

          smartDroppable.trigger(el, {
            clientX: 90,
            clientY: 12
          });

          expect(el.classList.contains('pb-over')).to.be.false();
          expect(Utils.toArray(el.children)).to.be.eql([lastDraggedEl]);
          expect(lastDraggedEl.style.left).to.be.equal('22px');
          expect(lastDraggedEl.style.top).to.be.equal('-100px');
          expect(lastDraggedEl.attachedCallback).calledWith().at.least(1);
          expect(DragDrop.dragEnd).calledWith().at.least(1);
        });
        it('should only remove the pb-over class if there are no last dragged elements', () => {
          el.classList.add('pb-over');

          smartDroppable.trigger(el, {
            clientX: 90,
            clientY: 12
          });

          expect(el.classList.contains('pb-over')).to.be.false();
        });
      });

      describe('#register', () => {
        it('should start observing mutations to children', () => {
          _.spy(smartDroppable[__mutationObserver__], 'observe');

          smartDroppable.register(el);

          expect(smartDroppable[__mutationObserver__].observe)
              .calledWith(el, { childList: true })
              .at.least(1);
        });
      });

      describe('#unregister', () => {
        it('should disconnect the mutation observer', () => {
          _.spy(smartDroppable[__mutationObserver__], 'disconnect');

          smartDroppable.unregister(el);

          expect(smartDroppable[__mutationObserver__].disconnect).calledWith().at.least(1);
        });
      });

      describe('__onDomMutation__', () => {
        it('should set the left and top of removed elements to 0, 0', () => {
          let el1 = { style: {} };
          let el2 = { style: {} };
          let el3 = { style: {} };

          smartDroppable[__onDomMutation__]([
            { removedNodes: [ el1, el2 ] },
            { removedNodes: [ el3 ] }
          ]);

          expect(el1.style).to.be.eql({ left: 0, top: 0 });
          expect(el2.style).to.be.eql({ left: 0, top: 0 });
          expect(el3.style).to.be.eql({ left: 0, top: 0 });
        });
      });
    });

    afterEach(done => {
      _.reset();
      done();
    });
  });
  });
  </script>
</body>