<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>Key Unit Tests</title>
  <link rel="import" href="third_party/di.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="testing/fakeability.html">
  <link rel="import" href="testing/fakeevents.html">
  <link rel="import" href="testutils.html">
  <link rel="import" href="trigger/key.html">
</head>
<body>
<script>
DIJS
.constant('doc', document.currentScript.ownerDocument)
.constant('pb.ui.MoveService', {
  mouseX: 0,
  mouseY: 0,
  movedElements: new Set()
})
.constant('pb.trigger.Key.__service__', {
  add() {},
  remove() {}
})
.with('pb.$registry', require => new (require('pb.ui.RegistryService'))())
.with('pb.Events', require => {
  const FakeEvents = require('pb.testing.FakeEvents');
  return new FakeEvents();
})
.run(require => {

  const doc = require('doc');
  const Events = require('pb.Events');
  const FakeAbility = require('pb.testing.FakeAbility');
  const j = require('jasmine');
  const Key = require('pb.trigger.Key');
  const KeyService = require('pb.trigger.Key.__service__');
  const Move = require('pb.ui.MoveService');
  const Service = require('pb.trigger.Key.__service__.__ctor__');
  const t = require('pb.t');

  describe('trigger.Key', () => {
    let key;

    beforeEach(() => {
      key = new Key('a');
    });

    describe('#on', () => {
      it('should register mouseenter, mouseleave, and using keyboardjs', () => {
        let element = doc.createElement('div');
        let ability = new FakeAbility('test');
        let event = {};

        spyOn(Events, 'of').and.callThrough();
        spyOn(Events, 'on').and.callThrough();
        key.on(element, ability);

        expect(Events.of).toHaveBeenCalledWith(element, key);

        spyOn(KeyService, 'add');
        spyOn(KeyService, 'remove');

        expect(Events.on).toHaveBeenCalledWith('dom', 'mouseenter', j.any(Function));
        expect(Events.on).toHaveBeenCalledWith('dom', 'mouseleave', j.any(Function));

        Events.on.calls.argsFor(0)[2]();
        expect(KeyService.add).toHaveBeenCalledWith(element, 'a', ability);

        Events.on.calls.argsFor(1)[2]();
        expect(KeyService.remove).toHaveBeenCalledWith(element);
      });
    });

    describe('#off', () => {
      it('should unregister all listeners', () => {
        let element = doc.createElement('div');
        spyOn(Events, 'of').and.callThrough();
        spyOn(Events, 'off').and.callThrough();

        key.off(element);

        expect(Events.of).toHaveBeenCalledWith(element, key);
        expect(Events.off).toHaveBeenCalledWith();
      });
    });

    describe('$Service', () => {
      let service;

      beforeEach(() => {
        service = new Service();
      });

      describe('__onKeyPress__', () => {
        let handler;

        beforeEach(() => {
          spyOn(Events, 'on');

          service.init(doc);
          handler = Events.on.calls.argsFor(0)[2];
        });

        it('should trigger only the deepest hovered element and unlisten to the element if the mouse is not on the element', () => {
          let el1 = doc.createElement('div');
          let el2 = doc.createElement('div');
          el1.appendChild(el2);

          let ability1 = new FakeAbility('ability1');
          let ability2 = new FakeAbility('ability2');
          service.add(el1, 'a', ability1);
          service.add(el2, 'a', ability2);

          spyOn(ability1, 'trigger');
          spyOn(ability2, 'trigger');
          spyOn(doc, 'elementFromPoint').and.returnValue(el2);

          spyOn(el2, 'getBoundingClientRect').and.returnValue({
            left: 12,
            right: 34,
            top: 56,
            bottom: 78
          });
          Move.mouseX = 0;
          Move.mouseY = 0;

          let event = {
            keyCode: 'a'.charCodeAt(0)
          };
          handler(event);

          expect(doc.elementFromPoint).toHaveBeenCalledWith(0, 0);

          // Check that the first ability is called.
          expect(ability1.trigger).not.toHaveBeenCalled();
          expect(ability2.trigger).toHaveBeenCalledWith(el2);

          // Check that the ability is deleted.
          expect(t.getPrivateProperty(service, 'hoveredEls').has(el2)).toEqual(false);
        });
        it('should not crash if no element is hovered over', () => {
          handler({ keyCode: 97 });
        });
        it('should not unlisten the element if the mouse is still in the element', () => {
          let el = doc.createElement('div');
          service.add(el, 'a', new FakeAbility('ability'));

          spyOn(el, 'getBoundingClientRect').and.returnValue({
            left: 12,
            right: 34,
            top: 56,
            bottom: 78
          });
          Move.mouseX = 20;
          Move.mouseY = 60;

          handler({ keyCode: 97 });

          // Check that the ability is still there.
          const map = t.getPrivateProperty(service, 'hoveredEls');
          expect(map.has(el)).toEqual(true);
        });
        it('should unlisten to the element if it is being moved', () => {
          let el = doc.createElement('div');
          service.add(el, 'a', new FakeAbility('ability'));
          spyOn(doc, 'elementFromPoint').and.returnValue(el);

          spyOn(el, 'getBoundingClientRect').and.returnValue({
            left: 10,
            right: 20,
            top: 10,
            bottom: 20
          });
          Move.mouseX = 15;
          Move.mouseY = 15;
          Move.movedElements.add(el);

          handler({ keyCode: 97 });

          // Check that the element has been unregistered.
          const map = t.getPrivateProperty(service, 'hoveredEls');
          expect(map.has(el)).toEqual(false);
        });
      });

      describe('init', () => {
        it('should listen to keypress events', () => {
          spyOn(Events, 'of').and.callThrough();
          spyOn(Events, 'on').and.callThrough();

          service.init(doc);
          expect(Events.of).toHaveBeenCalledWith(doc.body, service);
          expect(Events.on).toHaveBeenCalledWith('dom', 'keypress', j.any(Function));
        });
      });

      describe('add', () => {
        let el;

        beforeEach(() => {
          el = doc.createElement('div');
        });

        it('should add the element to the service', () => {
          const ability = new FakeAbility('ability');
          const key = 'a';
          service.add(el, key, ability);

          const map = t.getPrivateProperty(service, 'hoveredEls');
          expect(map.has(el)).toEqual(true);
          expect(map.get(el).has(key)).toEqual(true);
          expect(map.get(el).get(key).has(ability)).toEqual(true);
        });
        it('should handle adding multiple abilities with the same element and key', () => {
          const ability1 = new FakeAbility('ability1');
          const ability2 = new FakeAbility('ability2');
          const key = 'a';
          service.add(el, key, ability1);
          service.add(el, key, ability2);

          const abilitySet = t.getPrivateProperty(service, 'hoveredEls').get(el).get(key);
          expect(abilitySet.has(ability1)).toEqual(true);
          expect(abilitySet.has(ability2)).toEqual(true);
        });
        it('should handle adding multiple keys to the same element', () => {
          const key1 = 'a';
          const key2 = 'b';
          const ability = new FakeAbility('ability');

          service.add(el, key1, ability);
          service.add(el, key2, ability);

          const keyMap = t.getPrivateProperty(service, 'hoveredEls').get(el);
          expect(keyMap.has(key1)).toEqual(true);
          expect(keyMap.get(key1).has(ability)).toEqual(true);
          expect(keyMap.has(key2)).toEqual(true);
          expect(keyMap.get(key2).has(ability)).toEqual(true);
        });
      });

      describe('remove', () => {
        it('should remove the element from the map', () => {
          const el = doc.createElement('div');

          service.add(el, 'a', new FakeAbility('ability'));

          service.remove(el);
          expect(t.getPrivateProperty(service, 'hoveredEls').has(el)).toEqual(false);
        });
        it('should not crash if the element is not in the map', () => {
          service.remove(doc.createElement('div'));
        });
      });
    });
  });
});
</script>
</body>
