<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>data.LogService Unit Tests</title>

  <link rel="import" href="data/logservice.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
<script>
DIJS
.run(require => {
  const Entry = require('pb.data.LogService.__entry__');
  const j = require('jasmine');
  const Log = require('pb.data.LogService.__ctor__');

  describe('data.LogService$Entry', () => {
    let entry;

    beforeEach(() => {
      entry = new Entry();
    });

    it('should return the set value', () => {
      entry.set('key', 'value');
      expect(entry.key).toEqual('value');
    });
    it('should not allow values to be overridden by using set', () => {
      entry.set('key', 'value');
      expect(() => entry.set('key', 'newValue')).toThrowError();
    });
    it('should not allow properties to be overridden by using direct override', () => {
      entry.set('key', 'value');
      expect(() => entry.key = 'newValue').toThrowError();
    });
  });

  describe('data.LogService', () => {
    let TIMESTAMP = new Date(1234);
    let CATEGORY = 'test';
    let VALUE = 12;

    let log;

    beforeEach(() => {
      log = new Log();
    });

    describe('#log', () => {
      function expectEntryHas(entry, timestamp, category, value) {
        expect(entry.timestamp.getTime()).toEqual(timestamp.getTime());
        expect(entry.category).toEqual(category);
        expect(entry.value).toEqual(value);
      }

      it('should use the default processor when no processors are specified', () => {
        spyOn(Date, 'now').and.returnValue(TIMESTAMP);
        expect(log.log(CATEGORY, VALUE).entries)
            .toEqual(log.defaultPrinter({
              timestamp: TIMESTAMP,
              category: CATEGORY,
              value: VALUE
            }));
      });
      it('should use the specified preprocessors and call them in order', () => {
        let preprocessor1 = entry => entry.set('a', 1);
        let preprocessor2 = entry => entry.set('b', entry.a);
        let printer = j.createSpy('printer');
        let extras = {
          c: 3,
          d: 4
        };

        log
            .addPreprocessor(preprocessor1)
            .addPreprocessor(preprocessor2)
            .addPrinter(printer);

        log.log('category', 'value', extras);

        let matchingEntry = printer.calls.argsFor(0)[0];
        expect(matchingEntry.category).toEqual('category');
        expect(matchingEntry.value).toEqual('value');
        expect(matchingEntry.a).toEqual(1);
        expect(matchingEntry.b).toEqual(1);
        expect(matchingEntry.c).toEqual(3);
        expect(matchingEntry.d).toEqual(4);
      });
      it('should use the specified printer', () => {
        let entry = 'entry';
        let printer = j.createSpy('printer').and.returnValue(entry);

        spyOn(Date, 'now').and.returnValue(TIMESTAMP);

        log.addPrinter(printer);
        expect(log.log(CATEGORY, VALUE).entries).toEqual(entry);

        expectEntryHas(printer.calls.argsFor(0)[0], TIMESTAMP, CATEGORY, VALUE);
      });
      it('should print nothing if the printer returns empty string', () => {
        let printer1 = j.createSpy('printer1').and.returnValue('');
        let printer2 = j.createSpy('printer2').and.returnValue('value');

        log
            .addPrinter(printer1)
            .addPrinter(printer2);

        expect(log.log('category', 'value').entries).toEqual('');
      });
      it('should pick the first processor that returns a non null and non undefined', () => {
        let entry = 'entry';
        let printer = j.createSpy('printer').and.returnValue(entry);

        spyOn(Date, 'now').and.returnValue(TIMESTAMP);

        log
            .addPrinter(() => null)
            .addPrinter(() => undefined)
            .addPrinter(printer)
            .addPrinter(() => 'not used');
        expect(log.log(CATEGORY, VALUE).entries).toEqual(entry);

        let actualEntry = printer.calls.argsFor(0)[0];
        expect(actualEntry.timestamp.getTime()).toEqual(TIMESTAMP.getTime());
        expect(actualEntry.category).toEqual(CATEGORY);
        expect(actualEntry.value).toEqual(VALUE);
      });
      it('should not add any entries if there are no processors that returns a non empty string', () => {
        log
            .addPrinter(() => null)
            .addPrinter(() => '');
        expect(log.log(CATEGORY, VALUE).entries).toEqual('');
      });
    });

    describe('#blob', () => {
      it('should return a blob with the correct content and MIME type', done => {
        spyOn(Date, 'now').and.returnValue(TIMESTAMP);

        let blob = log.log(CATEGORY, VALUE).blob;
        let reader = new FileReader();
        reader.addEventListener('loadend', () => {
          expect(reader.result)
              .toEqual(log.defaultPrinter({
                timestamp: TIMESTAMP,
                category: CATEGORY,
                value: VALUE
              }));
          done();
        });
        reader.readAsText(blob);
      });
    });

    describe('#defaultPrinter', () => {
      it('should return undefined if the entry is in before phase', () => {
        let entry = {
          phase: 'before'
        };
        expect(log.defaultPrinter(entry)).toEqual(undefined);
      });
      it('should print something if the entry is in a phase other than before', () => {
        let entry = {
          timestamp: new Date(),
          phase: 'after',
          category: 'category',
          value: 'value'
        };
        expect(log.defaultPrinter(entry)).toBeATypeOf('string');
      });
    });
  });
});
</script>
</body>
