<!DOCTYPE html>
<html>
<head>
  <base href=".">
  <title>Utils Unit Tests</title>

  <link rel="import" href="testbase.html">

  <link rel="import" href="utils.html">
</head>
<body>
<template id="correctTemplate">Correct</template>
<template id="badTemplate">Wrong</template>

<script>
DIJS
    .constant('doc', document.currentScript.ownerDocument)
    .run(require => {

  const doc = require('doc');
  const j = require('jasmine');
  const Utils = require('pb.Utils');

  describe('Utils', () => {
    describe('#extractTemplate', () => {
      it('should extract the correct template', () => {
        let template = Utils.extractTemplate('#correctTemplate', doc);
        expect(template.textContent).toEqual('Correct');
      });
    });

    describe('#nonNullFn', () => {
      it('should return the referenced function if it exists', () => {
        let o = {
          f: () => 1
        };

        expect(Utils.nonNullFn(o, 'f')).toEqual(o.f);
      });

      it('should return noop function if it does not exist', () => {
        expect(Utils.nonNullFn({}, 'fn')()).toEqual(undefined);
      });
    });

    describe('#observe', () => {
      let o = { a: 1, b: 2 };

      it('should listen to a specific property when given the name', () => {
        let handler = j.createSpy('handler');
        spyOn(Object, 'observe');

        Utils.observe(o, 'a', handler);
        expect(Object.observe).toHaveBeenCalledWith(o, j.any(Function));

        // Emulate a change event on the listened property.
        let changeA = {
          name: 'a',
          type: 'type',
          oldValue: 'oldValue'
        };

        let changeB = {
          name: 'b',
          type: 'type',
          oldValue: 'oldValue'
        };
        Object.observe.calls.argsFor(0)[1]([changeA, changeB]);
        expect(handler).toHaveBeenCalledWith(changeA.name, changeA.type, changeA.oldValue);
        expect(handler).not.toHaveBeenCalledWith(changeB.name, j.any(), j.any());
      });
      it('should listen to all properties when not given any names', () => {
        let handler = j.createSpy('handler');
        spyOn(Object, 'observe');

        Utils.observe(o, null /* property */, handler);
        expect(Object.observe).toHaveBeenCalledWith(o, j.any(Function));

        // Emulate a change event on the listened property.
        let changeA = {
          name: 'a',
          type: 'typeA',
          oldValue: 'oldValueA'
        };

        let changeB = {
          name: 'b',
          type: 'typeB',
          oldValue: 'oldValueB'
        };
        Object.observe.calls.argsFor(0)[1]([changeA, changeB]);
        expect(handler).toHaveBeenCalledWith(changeA.name, changeA.type, changeA.oldValue);
        expect(handler).toHaveBeenCalledWith(changeB.name, changeB.type, changeB.oldValue);
      });
    });

    describe('#waitFor', () => {
      it('should immediate resolve when the property matches', done => {
        let o = { a: true };
        let handler = () => done();
        Utils.waitFor(o, 'a', true).then(handler);
      });
      it('should resolve when the property matches', done => {
        let o = { a: false };
        let handler = () => done();
        Utils.waitFor(o, 'a', true).then(handler);
        o.a = true;
      });
      it('should resolve when given a function', done => {
        let o = { a: 'value' };
        let handler = () => done();
        Utils.waitFor(o, 'a', v => v === 'value').then(handler);
      });
    });

    describe('#extendFn', () => {
      it('should call the original function before the new function by default', () => {
        let oldFn = j.createSpy('oldFn').and.returnValue(1);
        let newFn = j.createSpy('newFn').and.returnValue(2);

        let object = {
          fn: oldFn
        };

        Utils.extendFn(object, 'fn', newFn);
        expect(object.fn()).toEqual(2);
        expect(oldFn).toHaveBeenCalledWith();
      });
      it('should call the original function after the new function if specified', () => {
        let oldFn = j.createSpy('oldFn').and.returnValue(1);
        let newFn = j.createSpy('newFn').and.returnValue(2);

        let object = {
          fn: oldFn
        };

        Utils.extendFn(object, 'fn', newFn, true /* callBefore */);
        expect(object.fn()).toEqual(1);
        expect(newFn).toHaveBeenCalledWith();
      });
      it('should not crash if original function does not exist', () => {
        let object = {};
        let fn = j.createSpy('fn').and.returnValue(2);

        Utils.extendFn(object, 'fn', fn, true /** callBefore */);
        expect(object.fn()).toEqual(2);
        expect(fn).toHaveBeenCalledWith();
      });
    });

    describe('#curry', () => {
      it('should work when called with one argument at a time', () => {
        let fn = (a, b) => a + b;
        let curry = Utils.curry(fn);
        expect(curry(1)).toBeAnInstanceOf(Function);
        expect(curry(1)(2)).toEqual(3);
      });
      it('should work when called with multiple arguments', () => {
        let fn = (a, b) => a + b;
        let curry = Utils.curry(fn);
        expect(curry(1, 2)).toEqual(3);
      });
      it('should work for functions with no arguments', () => {
        let fn = () => 3;
        expect(Utils.curry(fn)()).toEqual(3);
      });
    });
  });
});
</script>
</body>
</html>
