<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>ability.Abilities Unit Tests</title>

  <link rel="import" href="ability/abilities.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="testing/fakeability.html">
  <link rel="import" href="testing/fakemutationobserver.html">
  <link rel="import" href="third_party/di.html">
  <link rel="import" href="ui/registryservice.html">
</head>
<body>
<script>
DIJS
.with('MutationObserver', require => require('pb.testing.FakeMutationObserver'))
.with('pb.$registry', require => new (require('pb.ui.RegistryService'))())
.run(require => {
  const Abilities = require('pb.ability.Abilities.__ctor__');
  const Builder = require('pb.ability.Abilities.__builder__');
  const FakeAbility = require('pb.testing.FakeAbility');
  const j = require('jasmine');
  const t = require('pb.t');
  const Utils = require('pb.Utils');

  const __abilities__ = require('pb.ability.Abilities.__symbols__').__abilities__;

  describe('ability.Abilities', () => {
    let abilities;
    let FakeElement;

    beforeEach(() => {
      abilities = new Abilities();

      FakeElement = function() {};
      FakeElement.prototype = Object.create(HTMLElement.prototype);
      FakeElement.prototype.constructor = FakeElement;
    });

    describe('#__onMutation__', () => {
      it('should call updateConfig for every record object', () => {
        let ability1 = new FakeAbility('ability 1');
        let ability2 = new FakeAbility('ability 2');
        let records = [
          {
            target: new FakeElement(),
            attributeName: ability1.attrName
          },
          {
            target: new FakeElement(),
            attributeName: ability2.attrName
          }
        ];

        abilities.of(FakeElement.prototype)
            .add(ability1)
            .add(ability2);

        spyOn(ability1, 'updateConfig');
        spyOn(ability2, 'updateConfig');

        t.getPrivateMethod(abilities, 'onMutation')(records);
        expect(ability1.updateConfig).toHaveBeenCalledWith(records[0].target);
        expect(ability2.updateConfig).toHaveBeenCalledWith(records[1].target);
      });
      it('should not throw exception if the element has no abilities', () => {
        t.getPrivateMethod(abilities, 'onMutation')([{
          target: new FakeElement(),
          attributeName: 'attributeName'
        }]);
      });
      it('should not throw exception if the element has no attribute that has been mutated', () => {
        let ability = new FakeAbility('ability');
        ability.attrName = 'attrName';
        ability.attrTrigger = 'attrTrigger';

        let el = new FakeElement();
        abilities.of(FakeElement.prototype).add(ability);

        t.getPrivateMethod(abilities, 'onMutation')([{ target: el, attributeName: 'nonExistent' }]);
      });
    });

    describe('#init', () => {
      let el;

      beforeEach(() => {
        el = new FakeElement();
      });

      it('should observe mutation and call set default value for every registered ability', () => {
        let ability1 = new FakeAbility('ability 1');
        let ability2 = new FakeAbility('ability 2');

        abilities.of(FakeElement.prototype)
            .add(ability1)
            .add(ability2);

        spyOn(Utils, 'extendFn');
        spyOn(ability1, 'init');
        spyOn(ability2, 'init');

        abilities.init(el);

        expect(ability1.init).toHaveBeenCalledWith(el);
        expect(ability2.init).toHaveBeenCalledWith(el);

        let observer = t.getPrivateProperty(el, 'observer');
        spyOn(observer, 'observe');
        spyOn(observer, 'disconnect');

        // Check the attached callback.
        expect(Utils.extendFn).toHaveBeenCalledWith(el, 'attachedCallback', j.any(Function));
        Utils.extendFn.calls.argsFor(0)[2]();

        expect(observer.observe).toHaveBeenCalledWith(
            el,
            j.objectContaining({ attributes: true }));

        // Check the detached callback.
        expect(Utils.extendFn).toHaveBeenCalledWith(el, 'detachedCallback', j.any(Function));
        Utils.extendFn.calls.argsFor(1)[2]();

        expect(observer.disconnect).toHaveBeenCalledWith();
      });
      it('should handle element with no registered abilities', () => {
        abilities.init(el);
        expect(t.getPrivateProperty(el, 'observer')).toBeAnInstanceOf(MutationObserver);
      });
      it('should throw exception if the element has been initialized', () => {
        abilities.init(el);
        expect(() => abilities.init(el)).toThrowError(/already initialized/);
      });
    });

    describe('#trigger', () => {
      let el;

      beforeEach(() => {
        el = new FakeElement();
      });

      it('should trigger the ability', () => {
        let ability = new FakeAbility('ability');
        abilities.of(FakeElement.prototype).add(ability);

        spyOn(ability, 'trigger');
        abilities.trigger(el, ability.attrName);
        expect(ability.trigger).toHaveBeenCalledWith(el);
      });
      it('should throw error if the element has no abilities', () => {
        expect(() => abilities.trigger(el, 'ability')).toThrowError(Error);
      });
      it('should throw error if the element does not have the specified ability', () => {
        let ability = new FakeAbility('ability');
        abilities.of(FakeElement.prototype).add(ability);
        expect(() => abilities.trigger(el, 'other ability')).toThrowError(Error);
      });
    });

    describe('$Builder', () => {
      let builder;

      beforeEach(function(done) {
        builder = new Builder(FakeElement.prototype);
        done();
      });

      describe('#add', () => {
        it('should add ability to a clean element', () => {
          let ability = new FakeAbility('Ability');

          expect(builder.add(ability)).toEqual(builder);

          let addedAbilities = FakeElement.prototype[__abilities__];
          expect(addedAbilities.get(ability.attrName)).toEqual(ability);
          expect(addedAbilities.get(ability.attrTrigger)).toEqual(ability);
        });
        it('should add ability to an element with another ability', () => {
          let ability1 = new FakeAbility('Ability 1');
          let ability2 = new FakeAbility('Ability 2');

          expect(builder.add(ability1).add(ability2)).toEqual(builder);

          let addedAbilities = FakeElement.prototype[__abilities__];
          expect(addedAbilities.get(ability1.attrName)).toEqual(ability1);
          expect(addedAbilities.get(ability1.attrTrigger)).toEqual(ability1);

          expect(addedAbilities.get(ability2.attrName)).toEqual(ability2);
          expect(addedAbilities.get(ability2.attrTrigger)).toEqual(ability2);
        });
        it('should throw exception if an ability with the same name has been registered', () => {
          let ability1 = new FakeAbility('Ability');
          let ability2 = new FakeAbility('Ability');

          builder.add(ability1);

          expect(() => builder.add(ability2))
              .toThrowError(new RegExp(`${ability1.attrName} is already registered`));
        });
        it('should throw exception if an ability with the same trigger has been registered', () => {
          let ability1 = new FakeAbility('Ability');
          let ability2 = new FakeAbility('Ability');
          ability1.attrName = 'AttrName';
          ability2.attrName = 'AttrName2';

          builder.add(ability1);

          expect(() => builder.add(ability2))
              .toThrowError(new RegExp(`${ability1.attrTrigger} is already registered`));
        });
      });

      describe('#getAll', () => {
        it('should return the abilities correctly', () => {
          let ability = new FakeAbility('Ability');
          builder.add(ability);

          var map = builder.getAll();
          expect(map.size).toEqual(1);
          expect(map.get(ability.attrName)).toEqual(ability);
        });
        it('should return empty map if the element has no abilities', () => {
          expect(builder.getAll().size).toEqual(0);
        });
      });
    });
  });
});
</script>
</body>
