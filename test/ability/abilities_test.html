<!DOCTYPE html>
<html>
<head>
  <base href="../..">
  <title>Abilities Unit Tests</title>
  
  <link rel="import" href="out/testbase.html">
  
  <link rel="import" href="out/ability/abilities.html">
  <link rel="import" href="out/di.html">
</head>
<body>
  <script>
  DI
      .with('fakeTriggerable', t => t.createFakeAbility('fakeTriggerable'))
      .with('pb_ability_Triggerable', fakeTriggerable => {
        return (config, knownAbilities) => {
          fakeTriggerable.config = config;
          fakeTriggerable.knownAbilities = knownAbilities;
          return fakeTriggerable;
        };
      })
      .with('doc', () => document.currentScript.ownerDocument)
      .run((expect, _, _M, doc, pb_t, Abilities, HammerWrapper, fakeTriggerable) => {

  describe('Abilities', () => {
    let Ctor;

    beforeEach(done => {
      Ctor = function() {};
      Ctor.prototype = HTMLElement.prototype;
      Ctor.prototype.createdCallback = () => undefined;
      Ctor.prototype.addEventListener = _.spiedFunction();
      Ctor.prototype.removeEventListener = _.spiedFunction();
      Ctor.prototype.ownerDocument = doc;
      Ctor.prototype.style = {};
      done();
    });

    describe('#config', () => {
      it('should registers all the abilities and register the correct triggerable', () => {
        let ability1 = pb_t.createFakeAbility('ability1');
        let ability2 = pb_t.createFakeAbility('ability2');

        Abilities.config(Ctor, {'pb-click': ability1}, ability2);

        _.spy(HammerWrapper, 'on');

        let el = new Ctor();

        el.createdCallback();
        expect(ability1.setDefaultValue).calledWith(el).at.least(1);
        expect(ability2.setDefaultValue).calledWith(el).at.least(1);

        el.attributeChangedCallback('attr', 'oldValue', 'newValue');
        expect(ability1.attributeChangedCallback)
            .calledWith(el, 'attr', 'oldValue', 'newValue').at.least(1);
        expect(ability2.attributeChangedCallback)
            .calledWith(el, 'attr', 'oldValue', 'newValue').at.least(1);

        el.attachedCallback();
        expect(ability1.attachedCallback).calledWith(el).at.least(1);
        expect(ability2.attachedCallback).calledWith(el).at.least(1);

        // Check the configurations passed to the fake Triggerable
        expect(fakeTriggerable.config).to.be.eql({ 'pb-click': 'ability1' });
        expect(fakeTriggerable.knownAbilities).to.be.eql(new Set([ ability1, ability2 ]));

        el.detachedCallback();
        expect(ability1.detachedCallback).calledWith(el).at.least(1);
        expect(ability2.detachedCallback).calledWith(el).at.least(1);
      });
    });

    describe('#trigger', () => {
      it('should trigger the registered ability', () => {
        let ability = pb_t.createFakeAbility('ability');
        ability.trigger = _.spiedFunction();
        
        Abilities.config(Ctor, {'pb-click': ability});

        let el = new Ctor();
        el.createdCallback();
        Abilities.trigger(el, ability.constructor);
        expect(ability.trigger).calledWith(el).at.least(1);
      });
      it('shoud throw exception if the ability cannot be found', () => {
        let el = new Ctor();
        el.createdCallback();
        expect(() => Abilities.trigger(el, {name: 'unknown'})).to.throw('unknown');
      });
    });

    afterEach(done => {
      _.reset();
      done();
    });
  });
  });
  </script>
</body>