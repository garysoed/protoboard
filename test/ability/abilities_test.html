<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>ability.Abilities Unit Tests</title>

  <link rel="import" href="testbase.html">

  <link rel="import" href="ability/abilities.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
  <script>
  DI
      .prefix('pb')
      .with('fakeTriggerable', { t: '=' }, $i => $i.$i.t.createFakeAbility('fakeTriggerable'))
      .with('ability.Triggerable', { fakeTriggerable: '=' }, fakeTriggerable => {
        return (config, knownAbilities) => {
          $i.fakeTriggerable.config = config;
          $i.fakeTriggerable.knownAbilities = knownAbilities;
          return $i.fakeTriggerable;
        };
      })
      .constant('doc', document.currentScript.ownerDocument)
      .run(
          {
            expect: '/=',
            _: '/=',
            _M: '/=',
            doc: '=',
            t: '=',
            Abilities: 'ability.=',
            Utils: '='
          },
          $i => {

  describe('ability.Abilities', () => {
    describe('$Builder', () => {

      let el;
      let builder;

      beforeEach(done => {
        el = $i.doc.createElement('div');
        builder = new $i.Abilities.Builder(el);
        done();
      });

      describe('#add', () => {
        it('should add ability to a clean element', () => {
          let ability = $i.t.createFakeAbility('Ability');

          $i.expect(builder.add(ability)).to.equal(builder);

          let abilities = el[$i.t.getSymbol(el, 'abilities')];
          $i.expect(abilities.get(ability.attrName)).to.equal(ability);
          $i.expect(abilities.get(ability.attrTrigger)).to.equal(ability);
        });
        it('should add ability to an element with another ability', () => {
          let ability1 = $i.t.createFakeAbility('Ability 1');
          let ability2 = $i.t.createFakeAbility('Ability 2');

          $i.expect(builder.add(ability1).add(ability2)).to.equal(builder);

          let abilities = el[$i.t.getSymbol(el, 'abilities')];
          $i.expect(abilities.get(ability1.attrName)).to.equal(ability1);
          $i.expect(abilities.get(ability1.attrTrigger)).to.equal(ability1);

          $i.expect(abilities.get(ability2.attrName)).to.equal(ability2);
          $i.expect(abilities.get(ability2.attrTrigger)).to.equal(ability2);
        });
        it('should throw exception if an ability with the same name has been registered', () => {
          let ability1 = $i.t.createFakeAbility('Ability');
          let ability2 = $i.t.createFakeAbility('Ability');

          builder.add(ability1);

          $i.expect(() => builder.add(ability2))
              .to
              .throw(`${ability1.attrName} is already registered`);
        });
        it('should throw exception if an ability with the same trigger has been registered', () => {
          let ability1 = $i.t.createFakeAbility('Ability');
          ability1.attrName = 'AttrName';
          let ability2 = $i.t.createFakeAbility('Ability');
          ability2.attrName = 'AttrName2';

          builder.add(ability1);

          $i.expect(() => builder.add(ability2))
              .to
              .throw(`${ability1.attrTrigger} is already registered`);
        });
      });

      describe('#getAll', () => {
        it('should return the abilities correctly', () => {
          let ability = $i.t.createFakeAbility('Ability');
          builder.add(ability);

          var map = builder.getAll();
          $i.expect(map.size).to.be.equal(1);
          $i.expect(map.get(ability.attrName)).to.be.equal(ability);
        });
        it('should return empty map if the element has no abilities', () => {
          $i.expect(builder.getAll().size).to.be.equal(0);
        });
      });
    });

    describe('#__onMutation__', () => {

      const __onMutation__ = $i.t.getSymbol($i.Abilities, 'onMutation');

      it('should call updateConfig for every record object', () => {
        let ability1 = $i.t.createFakeAbility('ability 1');
        let ability2 = $i.t.createFakeAbility('ability 2');
        let records = [
          {
            target: $i.doc.createElement('div'),
            attributeName: ability1.attrName
          },
          {
            target: $i.doc.createElement('title'),
            attributeName: ability2.attrName
          }
        ];

        $i.Abilities.of(records[0].target).add(ability1);
        $i.Abilities.of(records[1].target).add(ability2);

        $i.Abilities[__onMutation__](records);
        $i.expect(ability1.updateConfig).calledWith(records[0].target).at.least(1);
        $i.expect(ability2.updateConfig).calledWith(records[1].target).at.least(1);
      });
      it('should not throw exception if the element has no abilities', () => {
        $i.Abilities[__onMutation__]([{
          target: $i.doc.createElement('div'),
          attributeName: 'attributeName'
        }]);
      });
      it('should not throw exception if the element has no attribute that has been mutated', () => {
        let ability = $i.t.createFakeAbility('ability');
        ability.attrName = 'attrName';
        ability.attrTrigger = 'attrTrigger';
        let el = $i.doc.createElement('div');

        $i.Abilities.of(el).add(ability);

        $i.Abilities[__onMutation__]([{ target: el, attributeName: 'nonExistent' }]);
      });
    });

    describe('#init', () => {
      let el;

      beforeEach(done => {
        el = $i.doc.createElement('div');
        done();
      });

      it('should observe mutation and call set default value for every registered ability', () => {
        let ability1 = $i.t.createFakeAbility('ability 1');
        let ability2 = $i.t.createFakeAbility('ability 2');

        $i.Abilities.of(el)
            .add(ability1)
            .add(ability2);

        $i._.spy($i.Utils, 'extendFn');

        $i.Abilities.init(el);

        $i.expect(ability1.init).calledWith(el).at.least(1);
        $i.expect(ability2.init).calledWith(el).at.least(1);

        let observer = el[$i.t.getSymbol(el, 'observer')];
        $i._.spy(observer, 'observe');
        $i._.spy(observer, 'disconnect');

        // Check the attached callback.
        let attachedCallbackCaptor = $i._M.isA(Function);
        $i.expect($i.Utils.extendFn)
            .calledWith(el, 'attachedCallback', attachedCallbackCaptor)
            .at
            .least(1);
        attachedCallbackCaptor.matchingArgs[0]();

        let configCaptor = $i._M.isA(Object);
        $i.expect(observer.observe).calledWith(el, configCaptor).at.least(1);

        let config = configCaptor.matchingArgs[0];
        $i.expect(config.attributes).to.be.true;

        // Check the detached callback.
        let detachedCallbackCaptor = $i._M.isA(Function);
        $i.expect($i.Utils.extendFn)
            .calledWith(el, 'detachedCallback', detachedCallbackCaptor)
            .at
            .least(1);
        detachedCallbackCaptor.matchingArgs[0]();

        $i.expect(observer.disconnect).calledWith().at.least(1);
      });
      it('should handle element with no registered abilities', () => {
        $i.Abilities.init(el);
        $i.expect(el[$i.t.getSymbol(el, 'observer')]).to.be.instanceOf(MutationObserver);
      });
      it('should throw exception if the element has been initialized', () => {
        $i.Abilities.init(el);
        $i.expect(() => $i.Abilities.init(el)).to.throw('already initialized');
      });
    });

    describe('#trigger', () => {
      let el;

      beforeEach(done => {
        el = $i.doc.createElement('div');
        done();
      });

      it('should trigger the ability', () => {
        let ability = $i.t.createFakeAbility('ability');
        $i.Abilities.of(el.constructor.prototype).add(ability);

        $i._.spy(ability, 'trigger');
        $i.Abilities.trigger(el, ability.attrName);
        $i.expect(ability.trigger).calledWith(el).at.least(1);
      });
      it('should throw error if the element has no abilities', () => {
        $i.expect(() => $i.Abilities.trigger(el, 'ability')).to.throw(Error);
      });
      it('should throw error if the element does not have the specified ability', () => {
        let ability = $i.t.createFakeAbility('ability');
        $i.Abilities.of(el.constructor.prototype).add(ability);
        $i.expect(() => $i.Abilities.trigger(el, 'other ability')).to.throw(Error);
      });

      afterEach(done => {
        $i.Abilities.of(el.constructor.prototype).reset();
        done();
      });
    });

    afterEach(done => {
      $i._.reset();
      done();
    });
  });
  });
  </script>
</body>
