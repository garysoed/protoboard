<!DOCTYPE html>
<html>
<head>
  <base href="../..">
  <title>Triggerable Unit Tests</title>
  <link rel="import" href="out/testbase.html">

  <link rel="import" href="out/di.html">
</head>
<body>
  <script>
  DI
      .with('doc', () => document.currentScript.ownerDocument)
      .run((expect, _, _M, doc, pb_t, Click, DoubleClick, Key, Triggerable, Utils) => {

  describe('Triggerable', () => {
    let el;

    // Private symbols.
    let __getTrigger__ = Utils.getSymbol(Triggerable.prototype, 'getTrigger');
    let __register__ = Utils.getSymbol(Triggerable.prototype, 'register');
    let __unregister__ = Utils.getSymbol(Triggerable.prototype, 'unregister');

    beforeEach(done => {
      el = doc.createElement('div');
      done();
    });

    describe('#setDefaultValue', () => {
      it('should set the default values for all supported types', () => {
        let ability1 = pb_t.createFakeAbility('ability1');
        let ability2 = pb_t.createFakeAbility('ability2');
        let triggerable = new Triggerable(
            {
              'pb-click': ability1.name,
              'pb-dblclick': ability2.name
            },
            [ ability1, ability2 ]);
        triggerable.setDefaultValue(el);

        expect($(el).attr('pb-click')).to.be.equal(ability1.name);
        expect($(el).attr('pb-dblclick')).to.be.equal(ability2.name);
      });
      it('should ignore unsupported type in default value', () => {
        let ability = pb_t.createFakeAbility('ability');
        let triggerable = new Triggerable(
            { 'pb-unknown': ability.name },
            [ ability ]);
        triggerable.setDefaultValue(el);

        expect($(el).attr('pb-unknown')).to.be.equal(undefined);
      });
      it('should not override attribute that is already set', () => {
        let ability = pb_t.createFakeAbility('ability');
        $(el).attr('pb-click', ability.name);

        let triggerable = new Triggerable(
            { 'pb-click': ability.name },
            [ ability ]);
        triggerable.setDefaultValue(el);

        expect($(el).attr('pb-click')).to.be.equal(ability.name);
      });
      it('should ignore unknown ability', () => {
        let triggerable = new Triggerable(
            { 'pb-click': 'unknownAbility' },
            []);
        triggerable.setDefaultValue(el);

        expect($(el).attr('pb-click')).to.be.equal(undefined);
      });
    });

    describe('#attributeChangedCallback', () => {
      it('should register new ability', () => {
        let name = 'ability';
        let ability = pb_t.createFakeAbility(name);
        let triggerable = new Triggerable({}, [ability]);

        _.spy(triggerable, __register__);

        triggerable.attributeChangedCallback(el, 'pb-click', null, name);

        expect(triggerable[__register__]).calledWith(el, _M.isA(Click), ability).at.least(1);
      });
      it('should unregister old ability', () => {
        let name = 'ability';
        let ability = pb_t.createFakeAbility(name);
        let triggerable = new Triggerable({}, [ability]);
        triggerable.attributeChangedCallback(el, 'pb-click', null, name);

        _.spy(triggerable, __unregister__).overrideReturn();
        triggerable.attributeChangedCallback(el, 'pb-click', name, null);

        expect(triggerable[__unregister__]).calledWith(el, _M.isA(Click)).at.least(1);
      });
      it('should handle changing triggers', () => {
        let triggerType = 'pb-click';
        let oldAbility = pb_t.createFakeAbility('oldAbility');
        let newAbility = pb_t.createFakeAbility('newAbility');
        let triggerable = new Triggerable({}, [oldAbility, newAbility]);

        triggerable.attributeChangedCallback(el, triggerType, null, 'oldAbility');

        _.spy(triggerable, __register__).overrideReturn();
        _.spy(triggerable, __unregister__).overrideReturn();
        triggerable.attributeChangedCallback(el, triggerType, 'oldAbility', 'newAbility');

        expect(triggerable[__unregister__]).calledWith(el, _M.isA(Click)).at.least(1);
        expect(triggerable[__register__]).calledWith(el, _M.isA(Click), newAbility).at.least(1);
        expect(triggerable[__unregister__]).calledWith(el, _M.isA(Click))
            .before(triggerable[__register__]).calledWith(el, _M.isA(Click), newAbility);
      });
      it('should ignore unsupported trigger', () => {
        let ability = pb_t.createFakeAbility('ability');
        let triggerable = new Triggerable({}, [ability]);

        _.spy(triggerable, __register__);

        triggerable.attributeChangedCallback(el, 'pb-unknown', null, ability.name);

        expect(triggerable[__register__]).called().to.be.equal(0);

      });
      it('should ignore unknown ability', () => {
        let triggerable = new Triggerable({}, []);

        _.spy(triggerable, __register__);

        triggerable.attributeChangedCallback(el, 'pb-click', null, 'unknownAbility');

        expect(triggerable[__register__]).called().to.be.equal(0);
      });
    });

    describe('#attachedCallback', () => {
      let abilityName = 'ability';
      let ability = pb_t.createFakeAbility(abilityName);

      it('should register all known trigger types', () => {
        $(el)
            .attr('pb-click', abilityName)
            .attr('pb-dblclick', abilityName);

        let triggerable = new Triggerable({}, [ ability ]);

        _.spy(triggerable, __register__);

        triggerable.attachedCallback(el);

        expect(triggerable[__register__]).calledWith(el, _M.isA(Click), ability).at.least(1);
        expect(triggerable[__register__]).calledWith(el, _M.isA(DoubleClick), ability).at.least(1);
      });
      it('should not crash when a trigger is not specified', () => {
        let triggerable = new Triggerable({}, [ ability ]);
        triggerable.attachedCallback(el);
      });
      it('should not crash if an ability is unknown', () => {
        $(el).attr('pb-click', 'unknownAbility');

        let triggerable = new Triggerable({}, []);
        triggerable.attachedCallback(el);
      });
    });

    describe('#detachedCallback', () => {
      it('should unregister all known trigger types', () => {
        let triggerable = new Triggerable();
        let triggerKeyA = triggerable[__getTrigger__]('pb-key-a');
        let triggerKeyB = triggerable[__getTrigger__]('pb-key-b');

        _.spy(triggerable, __unregister__).overrideReturn();
        triggerable.detachedCallback(el);

        expect(triggerable[__unregister__]).calledWith(el, _M.isA(Click)).at.least(1);
        expect(triggerable[__unregister__]).calledWith(el, _M.isA(DoubleClick)).at.least(1);
        expect(triggerable[__unregister__]).calledWith(el, triggerKeyA).at.least(1);
        expect(triggerable[__unregister__]).calledWith(el, triggerKeyB).at.least(1);
      });
    });

    describe('#__register__', () => {
      it('should register', () => {
        let ability = pb_t.createFakeAbility('ability');
        let triggerable = new Triggerable();
        let trigger = new Click();

        _.spy(trigger, 'on');

        triggerable[__register__](el, trigger, ability);

        expect(trigger.on).calledWith(el, ability).at.least(1);
      });
    });

    describe('#__unregister__', () => {
      it('should unregister', () => {
        let ability = pb_t.createFakeAbility('ability');
        let triggerable = new Triggerable();
        let trigger = new Click();

        _.spy(trigger, 'off').overrideReturn();

        triggerable[__unregister__](el, trigger);

        expect(trigger.off).calledWith(el).at.least(1);
      });
    });

    describe('#__getTrigger__', () => {
      let triggerable;
      beforeEach(done => {
        triggerable = new Triggerable();
        done();
      });

      it('should return a known non key trigger', () => {
        expect(triggerable[__getTrigger__]('pb-click')).instanceOf(Click);
      });
      it('should return a key trigger', () => {
        let trigger = triggerable[__getTrigger__]('pb-key-b');
        let __key__ = Utils.getSymbol(trigger, 'key');
        expect(trigger[__key__]).to.be.equal('b');
      });
      it('should cache the previously created key', () => {
        let trigger = triggerable[__getTrigger__]('pb-key-b');
        expect(triggerable[__getTrigger__]('pb-key-b')).to.be.equal(trigger);
        expect(triggerable[__getTrigger__]('pb-key-a')).to.not.be.equal(trigger);
      });
      it('should return null for unrecognizable trigger name', () => {
        expect(triggerable[__getTrigger__]('pb-unknown')).to.be.null();
      });
      it('should return null for invalid key', () => {
        expect(triggerable[__getTrigger__]('pb-key')).to.be.null();
      });
    });

    afterEach(done => {
      _.reset();
      done();
    });
  });
  });
  </script>
</body>
