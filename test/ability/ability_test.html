<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>ability.Ability Unit Tests</title>

  <link rel="import" href="ability/ability.html">
  <link rel="import" href="testbase.html">
  <link rel="import" href="testing/faketrigger.html">
  <link rel="import" href="testutils.html">
  <link rel="import" href="third_party/di.html">
</head>
<body>
<script>
DIJS
.constant('doc', document.currentScript.ownerDocument)
.constant('pb.data.AclService', { currentPlayer: 'player' })
.run(require => {

  const $ = require('pb.JQuery');
  const Ability = require('pb.ability.Ability');
  const AclService = require('pb.data.AclService');
  const doc = require('doc');
  const FakeTrigger = require('pb.testing.FakeTrigger');
  const Log = require('pb.data.LogService');
  const j = require('jasmine');
  const t = require('pb.t');
  const Triggers = require('pb.trigger.Triggers');

  describe('ability.Ability', () => {
    let el;

    beforeEach(() => {
      el = doc.createElement('div');
    });

    describe('#init', () => {
      it('should set the default value of the trigger', () => {
        let triggerStr = 'triggerStr';
        let trigger = new FakeTrigger(triggerStr);
        let ability = new Ability('name', trigger);

        spyOn(ability, 'updateConfig').and.returnValue();

        ability.init(el);
        expect($(el).attr(ability.attrTrigger)).toEqual(triggerStr);
        expect(ability.updateConfig).toHaveBeenCalledWith(el);
      });
      it('should do nothing if the default trigger is not provided', () => {
        let ability = new Ability('name');
        ability.init(el);
        expect($(el).attr(ability.attrTrigger)).not.toExist();
      });
      it('should not override the trigger value if it is already set', () => {
        let attrValue = 'value';
        let trigger = new FakeTrigger('triggerName');
        let ability = new Ability('name', trigger);
        $(el).attr(ability.attrTrigger, attrValue);

        spyOn(ability, 'updateConfig').and.returnValue();

        ability.init(el);
        expect($(el).attr(ability.attrTrigger)).toEqual(attrValue);
        expect(ability.updateConfig).toHaveBeenCalledWith(el);
      });
    });

    describe('#updateConfig', () => {
      it('should update the trigger if the trigger changes', () => {
        let trigger = new FakeTrigger('triggerName');
        let newTrigger = new FakeTrigger('new trigger');

        let ability = new Ability('name', trigger);

        spyOn(Triggers, 'parse');
        spyOn(trigger, 'off');
        spyOn(newTrigger, 'on');

        Triggers.parse.and.returnValue(trigger);
        ability.init(el);

        $(el).attr(ability.attrTrigger, newTrigger.toString());

        Triggers.parse.and.returnValue(newTrigger);
        ability.updateConfig(el);

        expect(trigger.off).toHaveBeenCalledWith(el);
        expect(Triggers.parse).toHaveBeenCalledWith(newTrigger.toString());
        expect(newTrigger.on).toHaveBeenCalledWith(el, ability);
        expect(el[t.getSymbol(el, 'triggerMap')].get(ability)).toEqual(newTrigger);
      });
      it('should be noop if the trigger does not change', () => {
        let trigger = new FakeTrigger('triggerName');
        let ability = new Ability('name', trigger);
        $(el).attr(ability.attrTrigger, trigger.toString());

        spyOn(Triggers, 'parse');
        spyOn(trigger, 'off');

        Triggers.parse.and.returnValue(trigger);
        ability.init(el);

        ability.updateConfig(el);

        expect(trigger.off).not.toHaveBeenCalled();
      });
      it('should not throw error if there are no triggers set', () => {
        let ability = new Ability('name');
        ability.updateConfig(el);
      });
    });

    describe('#trigger', () => {
      it('should log the call', () => {
        let name = 'name';
        let id = 'elId';
        let el = doc.createElement('div');
        let onTrigger = j.createSpy('onTrigger');
        $(el).attr('pb-id', id);

        spyOn(Log, 'log');

        let ability = new Ability(name, null);
        spyOn(ability, 'doTrigger').and.returnValue();
        spyOn(ability, 'isEnabled').and.returnValue(true);
        el.addEventListener(name, onTrigger);

        ability.trigger(el);

        // TODO(gs): Test the order of the logs getting called.
        expect(Log.log).toHaveBeenCalledWith(name, id, {
          phase: 'before',
          player: AclService.currentPlayer
        });
        expect(ability.isEnabled).toHaveBeenCalledWith(el);

        expect(ability.doTrigger).toHaveBeenCalledWith(el);
        expect(onTrigger).toHaveBeenCalledWith(j.objectContaining({
          detail: {
            ability: ability
          }
        }));

        expect(Log.log).toHaveBeenCalledWith(name, id, {
          phase: 'after',
          player: AclService.currentPlayer
        });
      });

      it('should not call doTrigger if not enabled', () => {
        let el = doc.createElement('div');
        let ability = new Ability(name, null);
        let onTrigger = j.createSpy('onTrigger');
        spyOn(Log, 'log');
        spyOn(ability, 'doTrigger').and.returnValue();
        spyOn(ability, 'isEnabled').and.returnValue(false);
        el.addEventListener(name, onTrigger);

        ability.trigger(el);

        expect(ability.isEnabled).toHaveBeenCalledWith(el);
        expect(ability.doTrigger).not.toHaveBeenCalled();
        expect(onTrigger).not.toHaveBeenCalled();
        expect(Log.log).not.toHaveBeenCalled();
      });
    });
  });
});
</script>
</body>
