<!DOCTYPE html>
<html>
<head>
  <base href="../..">
  <title>Draggable Unit Tests</title>

  <link rel="import" href="out/testbase.html">

  <link rel="import" href="out/ability/draggable.html">
  <link rel="import" href="out/events.html">
  <link rel="import" href="out/di.html">
  <link rel="import" href="out/service/dragdrop.html">
  <link rel="import" href="out/utils.html">
</head>
<body>
  <script>
  DI
      .with('doc', () => document.currentScript.ownerDocument)
      .run((
          expect,
          _,
          _M,
          doc,
          DragDrop,
          Draggable,
          Events,
          Utils) => {

  // Private symbols.
  let __onDragStart__ = Utils.getSymbol(Draggable.prototype, 'onDragStart');

  describe('Draggable', () => {
    let el;
    let child1;
    let child2;

    beforeEach(done => {
      el = doc.createElement('div');
      child1 = doc.createElement('div');
      child2 = doc.createElement('div');
      el.appendChild(child1);
      el.appendChild(child2);
      done();
    });

    function expectRegistered() {
      // Check that dragstart listener is registered to both children.
      let dragStartCaptor = _M.isA(Function);
      expect(child1.addEventListener).calledWith('dragstart', dragStartCaptor).at.least(1);
      expect(child2.addEventListener).calledWith('dragstart', dragStartCaptor).at.least(1);

      let dragStartHandler = dragStartCaptor.matchingArgs[0];
      let event = {
        dataTransfer: {}
      };

      dragStartHandler(event);

      expect(el.classList.contains('pb-dragged')).to.be.true;

      // Check that dragend listener is registered to both children.
      let dragEndCaptor = _M.isA(Function);
      expect(child1.addEventListener).calledWith('dragend', dragEndCaptor).at.least(1);
      expect(child2.addEventListener).calledWith('dragend', dragEndCaptor).at.least(1);

      dragEndCaptor.matchingArgs[0](el);

      expect(el.classList.contains('pb-dragged')).to.be.false;
    }

    function getRegisteredHandler(el, eventName) {
      let handlerCaptor = _M.isA(Function);
      expect(child1.addEventListener).calledWith('dragstart', handlerCaptor).at.least(1);
      return handlerCaptor.matchingArgs[0];
    }

    function expectUnregistered(draggable) {
      expect(Events.of(draggable, child1).hasListener('dragstart')).to.be.false;
      expect(Events.of(draggable, child1).hasListener('dragend')).to.be.false;

      expect(Events.of(draggable, child2).hasListener('dragstart')).to.be.false;
      expect(Events.of(draggable, child2).hasListener('dragend')).to.be.false;
    }

    describe('#setDefaultValue', () => {
      it('should set the value', () => {
        new Draggable(true).setDefaultValue(el);
        expect($(el).attr('pb-draggable')).to.be.equal('true');
      });
      it('should not do anything if value is already set', () => {
        $(el).attr('pb-draggable', false);
        new Draggable(true).setDefaultValue(el)
      });
    });

    describe('#attributeChangedCallback', () => {
      let draggable;

      beforeEach(done => {
        draggable = new Draggable(true);
        done();
      });

      it('should register if set to enabled', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');

        draggable.attributeChangedCallback(el, 'pb-draggable', 'false', 'true');

        expectRegistered();
      });
      it('should unregister if set to disabled', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');

        draggable.attributeChangedCallback(el, 'pb-draggable', 'false', 'true');

        _.spy(child1, 'removeEventListener');
        _.spy(child2, 'removeEventListener');
        
        draggable.attributeChangedCallback(el, 'pb-draggable', 'true', 'false');

        expectUnregistered(draggable);
      });
      it('should ignore unsupported attributes', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');
        _.spy(child1, 'removeEventListener');
        _.spy(child2, 'removeEventListener');

        draggable.attributeChangedCallback(el, 'unsupported-attribute', 'old', 'new');

        expect(child1.addEventListener).called().to.be.equal(0);
        expect(child2.addEventListener).called().to.be.equal(0);
        expect(child1.removeEventListener).called().to.be.equal(0);
        expect(child2.removeEventListener).called().to.be.equal(0);
      });
    });

    describe('#attachedCallback', () => {
      let draggable;
      
      beforeEach(done => {
        draggable = new Draggable(true);
        done();
      });

      it('should register if enabled', () => {
        $(el).attr('pb-draggable', 'true');

        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');

        draggable.attachedCallback(el);

        expectRegistered();
      });
      it('should do nothing if not enabled', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');
        $(el).attr('pb-draggable', 'false');

        draggable.attachedCallback(el);

        expect(child1.addEventListener).called().to.be.equal(0);
        expect(child2.addEventListener).called().to.be.equal(0);
      });
      it('should do nothing if not specified', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');

        draggable.attachedCallback(el);

        expect(child1.addEventListener).called().to.be.equal(0);
        expect(child2.addEventListener).called().to.be.equal(0);
      });
    });

    describe('#detachedCallback', () => {
      let draggable;

      beforeEach(done => {
        draggable = new Draggable(true);
        done();
      });

      it('should unregister', () => {
        _.spy(child1, 'addEventListener');
        _.spy(child2, 'addEventListener');

        $(el).attr('pb-draggable', 'true');

        draggable.attachedCallback(el);

        _.spy(child1, 'removeEventListener');
        _.spy(child2, 'removeEventListener');
        
        draggable.detachedCallback(el);

        expectUnregistered(draggable);
      });
    });

    describe('#__onDragStart__', () => {
      it('should set the data transfer object, add the CSS class, and call DragDrop service', () => {
        let draggable = new Draggable(true);
        let dataTransfer = {};
        let event = {
          clientX: 1,
          clientY: 2,
          dataTransfer: dataTransfer
        };

        _.spy(el, 'getBoundingClientRect').overrideReturn({
          left: 4,
          top: 8
        });
        _.spy(DragDrop, 'dragStart');

        draggable[__onDragStart__](el, event);

        expect(el.classList.contains('pb-dragged')).to.be.true();
        expect(DragDrop.dragStart).calledWith(el, -3, -6);
      });
    });

    afterEach(done => {
      _.reset();
      done();
    });
  });
  });
  </script>
</body>