<!DOCTYPE html>
<html>
<head>
  <base href="..">
  <title>Inject Unit Tests</title>

  <link rel="import" href="out/testbase.html">
  
  <link rel="import" href="out/inject.html">
</head>
<body>
  <script>
    'use strict';

    (() => {
      let expect = chai.expect;
      let _ = spies.Spies;

      let doc = document.currentScript.ownerDocument;

      describe('Inject', () => {
        let a_aa = 'a_aa';
        let a_ab = 'a_ab';

        before(done => {
          Inject.provide('test_a_aa', () => a_aa);
          Inject.provide('test_a_ab', () => a_ab);
          done();
        });

        describe('#provide', () => {
          it('should inject the correct values', () => {
            let value = 'value';
            let fn = _.spiedFunction();
            Inject.provide('test_value', (a_aa, ab) => {
              fn(a_aa, ab);
              return value;
            });

            expect(fn).calledWith(a_aa, a_ab).at.least(1);
            expect(Inject.get('test_value')).to.be.equal(value);
          });
          it('should throw error when an injected key cannot be found', () => {
            expect(() => Inject.provide('test_fail', a => undefined)).to.throw(/Cannot find/);
          });
        });

        describe('#with', () => {
          it('should inject using the provided local object', () => {
            let value = 'value';
            let fn = _.spiedFunction();
            let abcValue = 123;
            Inject
                .with('abc', abcValue)
                .provide('test_value', abc => {
                  fn(abc);
                  return value;
                });

            expect(fn).calledWith(abcValue).at.least(1);
            expect(Inject.get('test_value')).to.be.equal(value);
          });
          it('should not persist the bound value', () => {
            Inject
                .with('abc', 'abc')
                .provide('test_value', () => 1);
            expect(Inject.get('abc')).to.be.undefined();
          });
        });

        describe('#get', () => {
          let value = 2;

          beforeEach(done => {
            Inject.provide('test_suffix', () => value);
            done();
          });
          it('should return exact match', () => {
            expect(Inject.get('test_suffix')).to.be.equal(value);
          });
          it('should return suffix match', () => {
            expect(Inject.get('suffix')).to.be.equal(value);
          });
        });

        describe('#getProvider', () => {
          beforeEach(done => {
            Inject.provide('test_suffix', () => 2);
            done();
          });

          it('should return exact match', () => {
            expect(Inject.get('test_suffix')).to.be.not.undefined();
          });
          it('should return suffix match', () => {
            expect(Inject.get('suffix')).to.be.not.undefined();
          });
        })

        describe('$Provider', () => {
          describe('#inject', () => {
            it('should inject the correct values', () => {
              let value = 'value';
              let fn = _.spiedFunction();
              Inject.provide('test_provider', (aa, ab) => {
                fn(aa, ab);
                return value;
              });

              Inject.getProvider('test_provider').inject();
              expect(fn).calledWith(a_aa, a_ab).at.least(2);
            });
          });

          describe('#with', () => {
            it('should bind the provided value', () => {
              let newValue = 'newValue';
              let fn = _.spiedFunction();
              Inject.provide('test_provider', (aa, ab) => {
                fn(aa, ab);
                return 'value';
              });

              Inject
                  .getProvider('test_provider')
                  .with('aa', newValue)
                  .inject();
              expect(fn).calledWith(newValue, a_ab).at.least(1);
            });
            it('should not persist the provided value', () => {
              Inject.getProvider('test_a_aa')
                  .with('abc', 'abc')
                  .inject();

              expect(Inject.get('abc')).to.be.undefined();
            });
          });
        });

        afterEach(done => {
          _.reset();
          done();
        });
      });
    })();
  </script>
</body>