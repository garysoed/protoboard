<html><head>
  <base href="..">
  <title>Utils Unit Tests</title>

  <link rel="import" href="out/testbase.html">

  <link rel="import" href="out/utils.html">
</head>
<body>
  <template id="correctTemplate">Correct</template>
  <template id="badTemplate">Wrong</template>

  <script>"use strict";

DI.constant("doc", document.currentScript.ownerDocument).run(function (expect, _, _M, doc, Utils) {
  describe("Utils", function () {
    describe("#extractTemplate", function () {
      it("should extract the correct template", function () {
        var template = Utils.extractTemplate("#correctTemplate", doc);
        expect(template.textContent).to.be.equal("Correct");
      });
    });

    describe("#nonNullFn", function () {
      it("should return the referenced function if it exists", function () {
        var o = {
          f: function () {
            return 1;
          }
        };

        expect(Utils.nonNullFn(o, "f")).to.be.equal(o.f);
      });

      it("should return noop function if it does not exist", function () {
        expect(Utils.nonNullFn({}, "fn")()).to.be.undefined();
      });
    });

    describe("#observe", function () {
      var o = { a: 1, b: 2 };

      it("should listen to a specific property when given the name", function () {
        var handler = _.spiedFunction();
        _.spy(Object, "observe");

        Utils.observe(o, "a", handler);
        var isAFunction = _M.isA(Function);
        expect(Object.observe).calledWith(o, isAFunction).at.least(1);

        // Emulate a change event on the listened property.
        var changeA = {
          name: "a",
          type: "type",
          oldValue: "oldValue"
        };

        var changeB = {
          name: "b",
          type: "type",
          oldValue: "oldValue"
        };
        isAFunction.matchingArgs[0]([changeA, changeB]);
        expect(handler).calledWith(changeA.name, changeA.type, changeA.oldValue).at.least(1);
        expect(handler).calledWith(changeB.name, _M.any(), _M.any()).equal(0);
      });
      it("should listen to all properties when not given any names", function () {
        var handler = _.spiedFunction();
        _.spy(Object, "observe");

        Utils.observe(o, null, /* property */handler);
        var isAFunction = _M.isA(Function);
        expect(Object.observe).calledWith(o, isAFunction).at.least(1);

        // Emulate a change event on the listened property.
        var changeA = {
          name: "a",
          type: "typeA",
          oldValue: "oldValueA"
        };

        var changeB = {
          name: "b",
          type: "typeB",
          oldValue: "oldValueB"
        };
        isAFunction.matchingArgs[0]([changeA, changeB]);
        expect(handler).calledWith(changeA.name, changeA.type, changeA.oldValue).at.least(1);
        expect(handler).calledWith(changeB.name, changeB.type, changeB.oldValue).at.least(1);
      });
    });

    describe("#waitFor", function () {
      it("should immediate resolve when the property matches", function (done) {
        var o = { a: true };
        var handler = function () {
          return done();
        };
        Utils.waitFor(o, "a", true).then(handler);
      });
      it("should resolve when the property matches", function (done) {
        var o = { a: false };
        var handler = function () {
          return done();
        };
        Utils.waitFor(o, "a", true).then(handler);
        o.a = true;
      });
      it("should resolve when given a function", function (done) {
        var o = { a: "value" };
        var handler = function () {
          return done();
        };
        Utils.waitFor(o, "a", function (v) {
          return v === "value";
        }).then(handler);
      });
    });

    describe("#extendFn", function () {
      it("should call the original function before the new function by default", function () {
        var oldFn = _.spiedFunction().overrideReturn(1);
        var newFn = _.spiedFunction().overrideReturn(2);

        var object = {
          fn: oldFn
        };

        Utils.extendFn(object, "fn", newFn);
        expect(object.fn()).to.be.equal(2);
        expect(oldFn).calledWith().before(newFn).calledWith();
      });
      it("should call the original function after the new function if specified", function () {
        var oldFn = _.spiedFunction().overrideReturn(1);
        var newFn = _.spiedFunction().overrideReturn(2);

        var object = {
          fn: oldFn
        };

        Utils.extendFn(object, "fn", newFn, true /* callBefore */);
        expect(object.fn()).to.be.equal(1);
        expect(newFn).calledWith().before(oldFn).calledWith();
      });
      it("should not crash if original function does not exist", function () {
        var object = {};
        var fn = _.spiedFunction().overrideReturn(2);

        Utils.extendFn(object, "fn", fn, true /** callBefore */);
        expect(object.fn()).to.be.equal(2);
        expect(fn).calledWith().at.least(1);
      });
    });

    describe("#curry", function () {
      it("should work when called with one argument at a time", function () {
        var fn = function (a, b) {
          return a + b;
        };
        var curry = Utils.curry(fn);
        expect(curry(1)).to.be["instanceof"](Function);
        expect(curry(1)(2)).to.be.equal(3);
      });
      it("should work when called with multiple arguments", function () {
        var fn = function (a, b) {
          return a + b;
        };
        var curry = Utils.curry(fn);
        expect(curry(1, 2)).to.be.equal(3);
      });
      it("should work for functions with no arguments", function () {
        var fn = function () {
          return 3;
        };
        expect(Utils.curry(fn)()).to.be.equal(3);
      });
    });
  });
});</script>

</body></html>