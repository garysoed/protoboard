<html><head><base href="..">

<link rel="import" href="third_party/di.html">
<link rel="import" href="ui/shape.html">

<template id="main">
  <style>::content > * {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
}

pb-u-shape {
  z-index: -1;
}

pb-u-shape::shadow #root {
  fill-opacity: 0;
  stroke: #8982B8;
}

.row {
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
}

.row:not(:last-child) {
  margin-bottom: -56.8px;
}

.row:nth-child(2n) {
  margin-left: 75px;
}

.tile {
  width: 100px;
  height: 100px;
  position: relative;
}

.tile:not(:last-child) {
  margin-right: 50px;
}</style>

  <div id="root">
    <div id="content"></div>
  </div>
</template>

<template id="row">
  <div class="row"></div>
</template>

<template id="tile">
  <div class="tile">
    <pb-u-shape shape="hexagon"></pb-u-shape>
    <content></content>
  </div>
</template>

<script>"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

DI.prefix("pb").constant("doc", document.currentScript.ownerDocument)["with"]("templateMain", ["=", function (doc) {
  return doc.querySelector("template#main");
}])["with"]("templateRow", ["=", function (doc) {
  return doc.querySelector("template#row");
}])["with"]("templateTile", ["=", function (doc) {
  return doc.querySelector("template#tile");
}]).bind("surface.HexGrid", ["service.=", "surface.=", "=", "=", "=", "=", function (Config, Grid, $registry, templateMain, templateRow, templateTile) {
  var EL_NAME = "pb-s-hexgrid";

  /**
   * A surface that lays out its children in a hexagonal grid. To use this, add attributes
   * `pb-row` and `pb-col` to the element `pb-s-hexgrid`. These are the number of rows and columns
   * in the grid.
   *
   * Add the contents of the grid as children of this element. Use `pb-row` and `pb-col` attributes
   * on them to indicate their positions in the grid.
   *
   * ```html
   * <pb-s-hexgrid pb-row="2" pb-col="3">
   *   <!-- Third column is empty -->
   *   <div pb-row="0" pb-col="0">Top Left</div>
   *   <div pb-row="0" pb-col="1">Top Middle</div>
   *   <div pb-row="1" pb-col="0">Bottom Left</div>
   *   <div pb-row="1" pb-col="1">Bottom Middle</div>
   * </pb-s-hexgrid>
   * ```
   *
   * You can customize the tiles by using `pb-s-hexgrid::shadow pb-u-shape::shadow .pb-shape` CSS
   * selector. Since the tiles use SVG, you will need to use SVG attributes like `fill`.
   *
   * To select tile on a specific location add selector by attribute `pb-row` and `pb-col`. For
   * example, to color tile (2, 3) red:
   *
   * ```css
   * pb-s-hexgrid::shadow [pb-col="2"][pb-row="3"] pb-u-shape::shadow .pb-shape {
   *   fill: red;
   * }
   * ```
   *
   * @class surface.HexGrid
   * @since 0.2.0
   * @extends surface.Grid
   */
  var HexGrid = (function (Grid) {
    function HexGrid() {
      if (Object.getPrototypeOf(HexGrid) !== null) {
        Object.getPrototypeOf(HexGrid).apply(this, arguments);
      }
    }

    _inherits(HexGrid, Grid);

    _prototypeProperties(HexGrid, null, {
      rootEl: {

        /**
         * The root element of the grid. All rows will be added as children to this element.
         *
         * @property rootEl
         * @type Element
         * @final
         */
        get: function () {
          return this.shadowRoot.querySelector("#content");
        },
        enumerable: true,
        configurable: true
      },
      mainTemplate: {

        /**
         * Main template to render. This will be added as the shadow root of the element.
         *
         * @property mainTemplate
         * @type Element
         * @final
         */
        get: function () {
          return templateMain;
        },
        enumerable: true,
        configurable: true
      },
      rowTemplate: {

        /**
         * Template to render for every row in the grid. Tiles will be added as children to this
         * element.
         *
         * @property rowTemplate
         * @type Element
         * @final
         */
        get: function () {
          return templateRow;
        },
        enumerable: true,
        configurable: true
      },
      tileTemplate: {

        /**
         * Template to render for every tile in the grid.
         *
         * @property tileTemplate
         * @type Element
         * @final
         */
        get: function () {
          return templateTile;
        },
        enumerable: true,
        configurable: true
      }
    });

    return HexGrid;
  })(Grid);

  Config.add(EL_NAME);
  $registry.add(EL_NAME, HexGrid.prototype);

  return HexGrid;
}]);</script></head><body></body></html>