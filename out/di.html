<html><head><base href=".">

<script src="../node_modules/di/out/bin.js">"use strict";</script>

<script>"use strict";

// (() => {

// // Private symbols.
// const __function__ = Symbol();
// const __localBindings__ = Symbol('localBindings');
// const __localScope__ = Symbol('localScope');
// const __name__ = Symbol();
// const __parentScope__ = Symbol('parentScope');
// const __prefix__ = Symbol('prefix');
// const __prefixes__ = Symbol();
// const __resolvedValues__ = Symbol();
// const __values__ = Symbol('values');

// const __createProvider__ = Symbol();
// const __get__ = Symbol('get');

// const FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
// const SEPARATOR = '_';

// class Provider {

//   /**
//    * @class DI.Provider
//    * @constructor
//    * @param {Function} fn The function whose arguments should be resolved. The names will be used as
//    *    the key.
//    * @param {Array} prefixes Array of prefixes to add to the given function's argument's names.
//    * @param {DI.Scope} localScope The local scope. This will be prioritized when checking for bound
//    *    values.
//    * @param {string} [name=null] Reference name of the provider. This is used for detecting cyclic
//    *    dependencies.
//    */
//   constructor(fn, prefixes, localScope, name = null) {
//     this[__function__] = fn;
//     this[__prefixes__] = prefixes;
//     this[__localScope__] = localScope;
//     this[__name__] = name;
//     this[__resolvedValues__] = new Map();
//   }

//   /**
//    * Resolves the provider. Resolved values are cached per scope.
//    *
//    * @method resolve
//    * @param {DI.Scope} scope The scope to resolve the value in.
//    * @return {Object} The resolved value for the given scope.
//    */
//   resolve(scope) {
//     if (!this[__resolvedValues__].has(scope)) {
//       let argsString = this[__function__].toString().match(FN_ARGS)[1];
//       let args = argsString ? argsString.split(',') : [];

//       let resolvedArgs = args.map((arg, i) => {
//         let prefix = this[__prefixes__].length > i ? this[__prefixes__][i] : '';
//         arg = arg.trim();

//         let optional = false;
//         let prefixEnd = prefix[prefix.length - 1];
//         if (prefixEnd === '?') {
//           prefix = prefix.substring(0, prefix.length - 1);
//           optional = true;
//         }

//         if (prefixEnd !== '/') {
//           arg = prefix ? `${prefix}.${arg}` : arg;
//         }

//         // TODO(gs): Handle cyclic dependency.
//         let value;

//         try {
//           // Check the local scope first.
//           value = this[__localScope__][__get__](arg, scope);

//           if (value === undefined) {
//             // If value cannot be resolved in the local scope, check the given scope.
//             value = scope[__get__](arg, scope);
//           }

//           if (value === undefined) {
//             // If value cannot be resolved in the local scope, check the global bindings.
//             value = getGlobal(arg, scope);
//           }
//         } catch (e) {
//           // TODO(gs): Make a shared method.
//           if (this[__name__]) {
//             throw `${e}\n\twhile providing ${this[__name__]}`;
//           } else {
//             throw `${e}\n\twhile running expression`;
//           }
//         }

//         if (value === undefined) {
//           if (optional) {
//             return undefined;
//           } else if (this[__name__]) {
//             throw `Cannot find ${arg} while providing ${this[__name__]}`;
//           } else {
//             throw `Cannot find ${arg} while running expression`;
//           }
//         }

//         return value;
//       });

//       let value;

//       try {
//         value = this[__function__].apply(null, resolvedArgs);
//       } catch (e) {
//         if (this[__name__]) {
//           throw `Uncaught exception ${e}\n\twhile running provider ${this[__name__]}`;
//         } else {
//           throw `Uncaught exception ${e}\n\twhile running expression`;
//         }
//       }

//       if (value === undefined && this[__name__]) {
//         console.warn(`Value of ${this[__name__]} is undefined`);
//       }

//       this[__resolvedValues__].set(scope, value);
//     }

//     return this[__resolvedValues__].get(scope);
//   }
// }

// class BindingTree {

//   /**
//    * Represents a tree of bound values keyed by binding key.
//    * @class DI.BindingTree
//    * @constructor
//    */
//   constructor() {
//     this[__values__] = new Map();
//   }

//   /**
//    * Adds the given key and value to the tree. The tree will try to bind using the last segment of
//    * the key. If this causes a conflict, it will create a subtree.
//    *
//    * @method add
//    * @param {string} key The key to bind the value to.
//    * @param {Object} value The value to be bound.
//    * @param {number} [depth=0] The depth of the key to use as binding key. This should not be
//    *    called from outside the class.
//    */
//   add(key, value, depth = 0) {
//     let segments = key.split(SEPARATOR);
//     let bindingKey = segments[segments.length - 1 - depth];

//     if (!this[__values__].has(bindingKey)) {
//       this[__values__].set(bindingKey, {
//         key: key,
//         value: value
//       });
//     } else {
//       // There is already a value corresponding to this key
//       let existingValue = this[__values__].get(bindingKey);
//       if (existingValue.key === key) {
//         throw `Key ${key} is already bound`;
//       }

//       let newTree = new BindingTree();
//       this[__values__].set(bindingKey, newTree);
//       newTree.add(existingValue.key, existingValue.value, depth + 1);
//       newTree.add(key, value, depth + 1);
//     }
//   }

//   /**
//    * Returns the value corresponding to the given key.
//    *
//    * @param {string} key Key of the value to return.
//    * @param {number} [depth=0] The depth of the key to use as binding key. This should not be
//    *    called from outside the class.
//    * @return {any} The bound value, or undefined if the value cannot be found, or if the key has
//    *    collision but collision cannot be resolved.
//    */
//   get(key, depth = 0) {
//     let segments = key.split(SEPARATOR);
//     let bindingKey = segments[segments.length - 1 - depth];

//     if (bindingKey === undefined) {
//       return undefined;
//     }

//     if (!this[__values__].has(bindingKey)) {
//       return undefined;
//     }

//     let value = this[__values__].get(bindingKey);
//     if (value instanceof BindingTree) {
//       return value.get(key, depth + 1);
//     } else {
//       return value.value;
//     }
//   }
// }

// class Scope {
//   /**
//    * Scope containing local bindings.
//    *
//    * @class DI.Scope
//    * @constructor
//    * @param {DI.Scope} [parentScope=null] The parent scope.
//    */
//   constructor(parentScope = null, prefix = '') {
//     this[__localBindings__] = new BindingTree();
//     this[__parentScope__] = parentScope;
//     this[__prefix__] = prefix;
//   }

//   [__createProvider__](value, name = null) {
//     let fn = value.splice(value.length - 1)[0];
//     let prefixes = value.map(prefix => {
//       return [this[__prefix__], prefix].filter(i => !!i).join('.');
//     });

//     return new Provider(fn, prefixes, this, name);
//   }

//   [__get__](key, scope) {
//     let provider = this[__localBindings__].get(key);
//     if (provider === undefined) {
//       if (this[__parentScope__]) {
//         return this[__parentScope__][__get__](key, scope);
//       } else {
//         return undefined;
//       }
//     } else {
//       return provider.resolve(scope);
//     }
//   }

//   /**
//    * Creates a new child scope with the given value bound to the given key in its local binding.
//    *
//    * @method with
//    * @param {string} key The key to bound the value to.
//    * @param {Function} fn The function to run. The function's arguments will be bound based on
//    *    their names.
//    * @return {DI.Scope} The newly created child scope.
//    */
//   with(key, value) {
//     let childScope = new Scope(this, this[__prefix__]);
//     childScope[__localBindings__]
//         .add(append(this[__prefix__], key), this[__createProvider__](value, key));
//     return childScope;
//   }

//   /**
//    * Creates a new child scope with the given value bound to the given key in its local binding.
//    * This is similar to {{#crossLink "DI.Scope/with"}}{{/crossLink}}, but the value is a constant.
//    *
//    * @method constant
//    * @param {string} key The key to bound the value to.
//    * @param {Object} value The object to bind to the given key.
//    * @return {DI.Scope} The newly created child scope.
//    */
//   constant(key, value) {
//     return this.with(key, [() => value]);
//   }

//   /**
//    * Globally binds the given value to the given key.
//    *
//    * @method bind
//    * @param {string} key The key to bound the value to.
//    * @param {Function} fn The function to run. The function's arguments will be bound based on
//    *    their names.
//    */
//   bind(key, value) {
//     bindings.add(append(this[__prefix__], key), this[__createProvider__](value, key));
//     return this;
//   }

//   /**
//    * Returns the provider bound to the given key and resolve it in this scope. This will first check
//    * for the local bindings, then its ancestors. If no binding is found in the ancestral path, this
//    * will check for the global bindings.
//    *
//    * @method get
//    * @param {string} key Key whose bound value should be returned.
//    * @return {any} The value bound to the given key, or undefined if no values can be found.
//    */
//   get(key) {
//     let value = this[__get__](append(this[__prefix__], key));
//     if (value === undefined) {
//       return getGlobal(key, this);
//     } else {
//       return value;
//     }
//   }

//   /**
//    * Runs the given function after injecting any dependencies.
//    *
//    * @method run
//    * @param {Function} fn The function to run. The function's arguments will be bound based on
//    *    their names.
//    */
//   run(fn) {
//     this[__createProvider__](fn).resolve(this);
//   }

//   /**
//    * Prefix any keys given to this scope with the given prefix.
//    *
//    * @method prefix
//    * @param {string} prefix The prefix to add.
//    * @return {DI.Scope} The newly created child scope with the given prefix.
//    */
//   prefix(prefix) {
//     return new Scope(this, append(prefix, this[__prefix__]));
//   }
// }

// const bindings = new BindingTree();

// function getGlobal(key, scope) {
//   let globalProvider = bindings.get(key);
//   if (globalProvider === undefined) {
//     return undefined;
//   } else {
//     return globalProvider.resolve(scope);
//   }
// }

// function append(l, r) {
//   return [l, r].filter(i => !!i).join('.');
// }

// const DI = new Scope();
// window['DI'] = DI;

// if (window['TEST_MODE']) {
//   DI.Scope = Scope;
//   DI.BindingTree = BindingTree;
//   DI.Provider = Provider;
//   DI.bindings = bindings;
// }

// })();</script></head><body></body></html>