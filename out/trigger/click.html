<html><head><base href="..">

<link rel="import" href="third_party/di.html">
<link rel="import" href="events.html">
<link rel="import" href="hammerwrapper.html">
<link rel="import" href="trigger/trigger.html">

<script>"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

DI.prefix("pb").bind("trigger.Click", ["", "", "trigger", function (Events, HammerWrapper, Trigger) {
  /**
   * Triggers an ability when the element is clicked.
   *
   * @class trigger.Click
   * @extends trigger.Trigger
   */
  var Click = (function (Trigger) {
    function Click() {
      if (Object.getPrototypeOf(Click) !== null) {
        Object.getPrototypeOf(Click).apply(this, arguments);
      }
    }

    _inherits(Click, Trigger);

    _prototypeProperties(Click, null, {
      on: {

        /**
         * Registers the given element to trigger the given ability when clicked.
         *
         * @method on
         * @param {Element} element Element to register.
         * @param {ability.Ability} ability The ability to trigger.
         */
        value: function on(element, ability) {
          Events.of(element, this).on("hammer", "singletap", ability.trigger.bind(ability, element));
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      off: {

        /**
         * Unregisters the given element from triggering the registered ability when clicked.
         *
         * @method off
         * @param {Element} element Element to unregister.
         */
        value: function off(element) {
          Events.of(element, this).off("hammer", "singletap");
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      toString: {

        /**
         * @method toString
         * @return {string} String pb-click
         */
        value: function toString() {
          return "pb-click";
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      helpText: {

        /**
         * The help text to be displayed by {{#crossLink "ability.Helpable"}}{{/crossLink}}.
         *
         * @property helpText
         * @type string
         * @final
         */
        get: function () {
          return "Click";
        },
        enumerable: true,
        configurable: true
      }
    });

    return Click;
  })(Trigger);

  /**
   * Parses the input string
   *
   * @method parse
   * @param {string} str The string to parse
   * @return {trigger.Click|undefined} The Click trigger if parse is successful, or `undefined`
   *    otherwise.
   * @static
   */
  Click.parse = function (str) {
    return str === "pb-click" ? new Click() : undefined;
  };

  return Click;
}]);</script></head><body></body></html>