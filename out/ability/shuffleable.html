<html><head><base href="..">

<link rel="import" href="ability/ability.html">
<link rel="import" href="check.html">
<link rel="import" href="third_party/di.html">
<link rel="import" href="third_party/jquery.html">
<link rel="import" href="utils.html">

<link rel="stylesheet" href="../bower_components/animate.css/animate.min.css">

<script>"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

DI.prefix("pb").bind("ability.Shuffleable", ["/", "ability", "", "trigger", "", function ($, Ability, Check, Click, Utils) {
  // Private symbols.
  var __defaultEnabled__ = Symbol();

  var Shuffleable = (function (Ability) {
    /**
     * Elements with this ability shuffles its children when triggered.
     *
     * @constructor
     * @class ability.Shuffleable
     * @param {string} [name=pb-shuffleable] Name of the ability.
     * @param {trigger.Trigger} [defaultTrigger=trigger.Click] Default trigger for the ability.
     * @param {boolean} [defaultEnabled=true] True iff the ability should be enabled by default.
     * @extends ability.Ability
     */
    function Shuffleable() {
      var _this = this;
      var name = arguments[0] === undefined ? "pb-shuffleable" : arguments[0];
      var defaultTrigger = arguments[1] === undefined ? new Click() : arguments[1];
      var defaultEnabled = arguments[2] === undefined ? true : arguments[2];
      return (function () {
        _get(Object.getPrototypeOf(Shuffleable.prototype), "constructor", _this).call(_this, name, defaultTrigger);

        _this[__defaultEnabled__] = defaultEnabled;
      })();
    }

    _inherits(Shuffleable, Ability);

    _prototypeProperties(Shuffleable, null, {
      init: {

        /**
         * Sets the default configuration for this ability on the given element.
         *
         * @method init
         * @param {Element} el The element to set the default configuration to.
         */
        value: function init(el) {
          _get(Object.getPrototypeOf(Shuffleable.prototype), "init", this).call(this, el);

          if ($(el).attr(this.attrName) === undefined) {
            $(el).attr(this.attrName, this[__defaultEnabled__]);
          }
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      trigger: {

        /**
         * Shuffles the given element's children, if this ability is enabled on the element.
         *
         * @method trigger
         * @param {Element} el Element whose children should be shuffled.
         */
        value: function trigger(el) {
          if (Check($(el).attr(this.attrName)).isBoolean().orUse(false)) {
            var pairs = Utils.toArray(el.children).map(function (child) {
              return [child, Math.random()];
            });
            pairs.sort(function (a, b) {
              return Utils.compare(a[1], b[1]);
            });

            var shuffled = pairs.map(function (pair) {
              return pair[0];
            });
            shuffled.forEach(function (shuffledEl) {
              el.appendChild(shuffledEl);

              if (shuffledEl.classList.contains("pb-shuffleable-animate")) {
                shuffledEl.classList.remove("pb-shuffleable-animate");
              }
              shuffledEl.classList.add("pb-shuffleable-animate");
            });

            // Animate the deck
            $(el).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function () {
              el.classList.remove("animated");
              el.classList.remove("wobble");
            });
            el.classList.add("animated");
            el.classList.add("wobble");
          }
        },
        writable: true,
        enumerable: true,
        configurable: true
      }
    });

    return Shuffleable;
  })(Ability);

  return Shuffleable;
}]);</script></head><body></body></html>