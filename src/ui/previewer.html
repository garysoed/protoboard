<base href="..">

<link rel="import" href="pbelement.html">
<link rel="import" href="service/config.html">
<link rel="import" href="service/preview.html">
<link rel="import" href="third_party/di.html">
<link rel="import" href="third_party/events.html">
<link rel="import" href="utils.html">

<template>
  <div id="root">
    <content></content>
  </div>
</template>

<script>
DI
    .prefix('pb')
    .constant('doc', document.currentScript.ownerDocument)
    .with('template', { doc: '=' }, $i => $i.doc.querySelector('template'))
    .bind('ui.Previewer',
        {
          $registry: '=',
          doc: '=',
          template: '=',
          Config: 'service.=',
          Events: '=',
          PbElement: '=',
          Preview: 'service.=',
          Utils: '=',
        },
        $i => {

  /**
   * Element that displays the innerHTML of the `pb-u-preview` of element currently being hovered
   * over. This works in tandem with {{#crossLink ui.Preview}}{{/crossLink}} and
   * {{#crossLink service.Preview}}{{/crossLink}}.
   *
   * @class ui.Previewer
   * @extends PbElement
   */

  const EL_NAME = 'pb-u-previewer';

  // Private symbols.
  const __previewElHandler__ = Symbol();

  const __onPreviewElChanged__ = Symbol('onPreviewElChanged');

  class Previewer extends $i.PbElement {

    /**
     * Called when the preview element has changed.
     *
     * @method __onPreviewElChanged__
     * @private
     */
    [__onPreviewElChanged__]() {
      if ($i.Preview.previewedEl) {
        this.innerHTML = $i.Preview.previewedEl.innerHTML;
      } else {
        this.innerHTML = '';
      }
    }

    /**
     * Called when the element is created
     *
     * @method createdCallback
     */
    createdCallback() {
      super.createdCallback();
      this.createShadowRoot()
          .appendChild($i.Utils.activateTemplate($i.template, $i.doc));

      this.attachedCallback();
    }

    /**
     * Called when the element is attached to the document.
     *
     * @method attachedCallback
     */
    attachedCallback() {
      super.attachedCallback();
      this[__previewElHandler__] = $i.Events.of($i.Preview, this)
          .on('jquery',
              $i.Preview.Events.ELEMENT_CHANGED,
              this[__onPreviewElChanged__].bind(this));
    }

    /**
     * Called when the element is detached from the document.
     *
     * @method detachedCallback
     */
    detachedCallback() {
      $i.Events.of($i.Preview, this).off();
      super.detachedCallback();
    }
  }

  $i.Config.add(EL_NAME);
  $i.$registry.add(EL_NAME, Previewer.prototype);

  return Previewer;
});
</script>
