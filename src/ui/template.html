<base href="../..">

<link rel="import" href="out/third_party/handlebars.html">

<link rel="import" href="out/check.html">
<link rel="import" href="out/pbelement.html">
<link rel="import" href="out/service/config.html">
<link rel="import" href="out/utils.html">

<script>
DI
    .bind('pb_ui_Template', ($registry, Check, Config, PbElement, Utils, Handlebars) => {

  /**
   * When this element is created, it will process a <a href="http://handlebarsjs.com/">Handlebars
   * JS</a> template and it is given and replace itself with the processed templates.
   *
   * To refer to the template, add `template="<template_selector>"`, where `template_selector` is a
   * CSS selector to the template element. This template element contains the Handlebars template.
   *
   * To pass in variables into the template, add `data-<name>="<var>"` attributes to the element,
   * where `name` is the key to be used in the template, and var is the property name accessible
   * globally.
   *
   * ```html
   * <template id="test">
   *   {{#with company}}
   *     Name is {{name}}
   *   {{/with}}
   * </template>
   *
   * <script>
   *   window['org'] = { name: 'GitHub' };
   * </script>
   *
   * <!-- The DIV content will be "Name is GitHub" -->
   * <div>
   *   <pb-u-template template="template#test" data-company="org"></pb-u-template>
   * </div>
   * ```
   *
   * This class also registers a `{{#pb-for <from> <to> <step>}}` block helper. This is a simple for
   * loop that copies the inner block several times. You can access the index of the loop using the
   * `@index` variable.
   *
   * @class ui.Template
   * @extends PbElement
   */

  const EL_NAME = 'pb-u-template';

  const ATTR_TEMPLATE = 'pb-template';

  // Private symbols.
  const __getGlobal__ = Symbol();

  class Template extends PbElement {

    [__getGlobal__](path) {
      return path.split('.').reduce((previousValue, currentValue) => {
        if (previousValue) {
          return previousValue[currentValue];
        } else {
          return previousValue;
        }
      }, window);
    }

    /**
     * Called when the element is created
     *
     * @method createdCallback
     */
    createdCallback() {
      super.createdCallback();

      // Get the data
      let dataPromises = [];
      for (let key in this.dataset) {
        let valueStr = this.dataset[key];
        let value = this[__getGlobal__](valueStr) || valueStr;
        if (value instanceof Promise) {
          dataPromises.push(value.then(result => {
            return [key, result];
          }));
        } else {
          dataPromises.push(Promise.resolve([key, value]));
        }
      }

      Promise.all(dataPromises)
          .then(dataArray => {
            let data = Utils.fromArrayOfArrays(dataArray);
            let templateStr = this.ownerDocument
                .querySelector($(this).attr('template'))
                .innerHTML
                .replace('&gt;', '>');
            $(this).replaceWith(Handlebars.compile(templateStr)(data));
          });
    }
  }

  // Use function since Handlebars changes the context of this.
  Handlebars.registerHelper('pb-for', function(from, to, step, options) {
    if (options === undefined) {
      // Shift the args if step is not defined.
      options = step;
      step = 1;
    }
    let rv = '';
    for (let i = Check(from).isInt().orThrows();
        i < Check(to).isInt().orThrows();
        i += Check(step).isInt().orThrows()) {
      let data = Handlebars.createFrame(options.data || {});
      data.index = i;
      rv += options.fn(this, { data: data });
    }
    return rv;
  });

  Config.add(EL_NAME);
  $registry.add(EL_NAME, Template.prototype);

  return Template;
});
</script>
