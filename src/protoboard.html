<base href=".">

<link rel="import" href="bootstrap.html">
<link rel="import" href="data/aclservice.html">
<link rel="import" href="net/cachedio.html">
<link rel="import" href="net/inmemoryio.html">
<link rel="import" href="net/sessionservice.html">
<link rel="import" href="third_party/di.html">

<script>
DIJS
.bind('pb.Protoboard.__runner__', require => {

  const CachedIO = require('pb.net.CachedIO');
  const InMemoryIO = require('pb.net.InMemoryIO');

  const __gameSyncPromise__ = Symbol('gameSyncPromise');
  const __io__ = Symbol();
  const __players__ = Symbol();
  const __setupFn__ = Symbol();

  /**
   * Runs the Protoboard game.
   *
   * @class Protoboard.Runner
   */
  class Runner {

    /**
     * @constructor
     * @param {net.AbstractIO} io Implementation of AbstractIO to use.
     * @param {Promise} gameSyncPromise Promise that will be resolved with a Game Sync object.
     * @class Protoboard.Runner
     */
    constructor(io, gameSyncPromise) {
      this[__gameSyncPromise__] = gameSyncPromise;
      this[__io__] = new CachedIO(io, new InMemoryIO());
      this[__players__] = [];
    }

    /**
     * Joins the game locally.
     *
     * @method join
     * @param {string} id ID of the player.
     * @param {Object} initialState Initial state of the player.
     * @return {Protoboard.Runner} This object for chaining.
     */
    join(id, initialState) {
      this[__players__].push({
        id: id,
        state: initialState
      });
      return this;
    }

    /**
     * Registers a function to be ran before the game is ran.
     *
     * @method setup
     * @param {Function} setupFn Function to be run before the game starts. This function has one
     *     argument, which is a function that can be used to retrieve Protoboard classes.
     * @return {Protoboard} This object for chainin.
     */
    setup(setupFn) {
      this[__setupFn__] = setupFn;
      return this;
    }

    /**
     * Runs the game on the given document object. Also makes available the following variables to
     * the templating system:
     *
     * -   `pb_playerCount`: Contains number of players in the game.
     * -   `pb_players`: Array of player objects. Each player object is an object with:
     *
     *     -   id: ID of the player
     *     -   state: The player's state
     *
     * -   `pb_state`: Contains the game state object.
     *
     * @method run
     * @param {Document} [doc] Document to run the game on. Defaults to the root document.
     * @return {Promise} Promise that will be resolved with a function when the game has started.
     *    Use this function to retrieve Protoboard classes.
     */
    run(doc = document) {
      return new Promise((resolve, reject) => {
        DIJS
            .constant('pb.net.IO', this[__io__])
            .run(require => {
              const AclService = require('pb.data.AclService');
              const Bootstrap = require('pb.Bootstrap');
              const SessionService = require('pb.net.SessionService');
              const StateService = require('pb.data.StateService');
              const TemplateService = require('pb.ui.TemplateService');

              this[__gameSyncPromise__](require)
                  .then(gameSync => {
                    // Join all the players to join locally.
                    let joinPromise = Promise.resolve();
                    for (let player of this[__players__]) {
                      joinPromise = joinPromise.then(player => {
                        return SessionService.join(gameSync, player.id, player.state);
                      }.bind(null, player));
                    }

                    // TODO(gs): Store the gamesync somewhere.
                    return Promise.all([gameSync, joinPromise]);
                  })
                  .then(values => {
                    // Wait for all the players to join.
                    let [gameSync, ...rest] = values;
                    return SessionService.start(gameSync)
                        .then(gameSync => gameSync.get());
                  })
                  .then(gameData => {
                    // Initialize the templates.
                    TemplateService.addData('pb_playerCount', gameData.playerCount);
                    TemplateService.addData('pb_players', gameData.players);
                    TemplateService.addData('pb_state', gameData.state);
                    return gameData;
                  })
                  .then(gameData => {
                    return Promise.all([
                      gameData,
                      Promise.resolve(this[__setupFn__] ? this[__setupFn__](require) : null)
                    ]);
                  })
                  .then(values => {
                    let [gameData, ...rest] = values;
                    return Promise.all([gameData, Bootstrap.run(doc)]);
                  })
                  .then(values => {
                    let [gameData, ...rest] = values;

                    // Set the current local player.
                    if (this[__players__].length > 0) {
                      AclService.currentPlayer = this[__players__][0].id;
                    }

                    // Initialize the state service.
                    StateService.put('pb_playerCount', gameData.playerCount);
                  })
                  .then(() => resolve(require));
        });
      });
    }
  }

  /**
   * Creates a runner for a new game.
   *
   * @method forNewGame
   * @param {net.AbstractIO} io AbstractIO implementation to use.
   * @param {number} playerCount Number of players in the game.
   * @param {Object} initialGameState Initial state of the game.
   * @return {Protoboard.Runner} The new instance of Protoboard.Runner.
   * @static
   */
  Runner.forNewGame = function(io, playerCount, initialGameState) {
    return new Runner(io, require => {
      const SessionService = require('pb.net.SessionService');
      return SessionService.create(playerCount, initialGameState);
    });
  };

  /**
   * Creates a runner for an existing game.
   *
   * @method forExistingGame
   * @param {net.AbstractIO} io AbstractIO implementation to use.
   * @param {string} gameId ID of the game to use.
   * @return {Protoboard.Runner} The new instance of Protoboard.Runner.
   * @static
   */
  Runner.forExistingGame = function(io, gameId) {
    return new Runner(io, require => {
      const SessionService = require('pb.net.SessionService');
      return Promise.resolve(SessionService.get(gameId));
    });
  };

  return Runner;
})
.bind('pb.Protoboard.__ctor__', require => {
  const DIJS = require('DIJS');
  const InMemoryIO = require('pb.net.InMemoryIO');
  const Runner = require('pb.Protoboard.__runner__');

  const __io__ = Symbol();
  const __setupFn__ = Symbol();

  /**
   * The entry point to Protoboard. Use this class to setup the game and run it.
   *
   * @class Protoboard
   * @static
   */
  class Protoboard {

    constructor() {
      this[__io__] = new InMemoryIO();
    }

    /**
     * Sets the game to use the given IO.
     *
     * @method withIo
     * @param {net.AbstractIO} io Implementation of Abstract IO to use.
     * @return {Protoboard} This object for chaining.
     */
    withIo(io) {
      this[__io__] = io;
      return this;
    }

    /**
     * Creates a game based on an existing game.
     *
     * @method forExistingGame
     * @param {string} gameId ID of game to use.
     * @return {Protoboard.Runner} The runner object.
     */
    forExistingGame(gameId) {
      return Runner.forExistingGame(this[__io__], gameId);
    }

    /**
     * Creates a new game.
     *
     * @method forNewGame
     * @param {number} [playerCount] Number of players that the game should have before starting.
     *    Defaults to 0.
     * @param {Object} [initialGameState] The initial state of the game. Defaults to empty string.
     * @return {Protoboard.Runner} The runner object.
     */
    forNewGame(playerCount = 0, initialGameState = {}) {
      return Runner.forNewGame(this[__io__], playerCount, initialGameState);
    }

    /**
     * Runs Protoboard game with default settings.
     *
     * @method run
     * @param {Document} doc = document The Document to run the game in.
     * @return {Promise} Promise that will be resolved with a function when the game has started.
     *    Use this function to retrieve Protoboard classes.
     */
    run(doc = document) {
      return this.forNewGame().run(doc);
    }
  }

  return Protoboard;
});

window['Protoboard'] = DIJS.run(require => {
  const Protoboard = require('pb.Protoboard.__ctor__');
  return new Protoboard();
});
</script>
