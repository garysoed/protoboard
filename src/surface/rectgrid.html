<base href="../..">

<link rel="import" href="out/third_party/jquery.html">

<link rel="import" href="out/check.html">
<link rel="import" href="out/pbelement.html">
<link rel="import" href="out/service/config.html">
<link rel="import" href="out/utils.html">

<template id="main">
  <style>
    #root {
      display: inline-block;
    }

    #content {
      display: flex;
      flex-direction: column;
    }

    .row {
      display: flex;
      flex-direction: row;
    }
  </style>

  <div id="root">
    <div id="content"></div>
  </div>
</template>

<template id="row">
  <div class="row"></div>
</template>

<template id="col">
  <div class="col">
    <content></content>
  </div>
</template>

<script>
DI
    .constant('doc', document.currentScript.ownerDocument)
    .with('templateMain', doc => doc.querySelector('template#main'))
    .with('templateRow', doc => doc.querySelector('template#row'))
    .with('templateCol', doc => doc.querySelector('template#col'))
    .bind('pb_surface_RectGrid', (
        $registry,
        Check,
        Config,
        PbElement,
        Utils,
        doc,
        templateMain,
        templateRow,
        templateCol) => {

  const ATTR_ROW = 'pb-row';
  const ATTR_COL = 'pb-col';
  const EL_NAME = 'pb-s-rectgrid';

  /**
   * A surface that lays out its components in a grid. To use this, add attributes `pb-row` and
   * `pb-col` to the element `pb-s-rectgrid`. These are the number of rows and columns in the grid.
   *
   * Add the contents of the grid as children of this element. Use `pb-row` and `pb-col` attributes
   * on them to indicate their positions in the grid.
   *
   * ```javascript
   * <pb-s-rectgrid pb-row="2" pb-col="3">
   *   <div pb-row="0" pb-col="0">Top Left</div>
   *   <div pb-row="0" pb-col="1">Top Right</div>
   *   <div pb-row="1" pb-col="0">Bottom Left</div>
   *   <div pb-row="1" pb-col="1">Bottom Right</div>
   * </pb-s-rectgrid>
   *
   * @class surface.RectGrid
   * @extends PbElement
   */
  class RectGrid extends PbElement {

    /**
     * Called when the element is created
     *
     * @method createdCallback
     */
    createdCallback() {
      super.createdCallback();

      // Create the shadow DOM.
      this.createShadowRoot()
          .appendChild(Utils.activateTemplate(templateMain, doc));

      // Initializes the data.
      let rowCount = Check($(this).attr(ATTR_ROW)).isInt().orThrows();
      let colCount = Check($(this).attr(ATTR_COL)).isInt().orThrows();
      let rootEl = this.shadowRoot.querySelector('#content');

      // Add the rows.
      for (let row = 0; row < rowCount; row++) {
        rootEl.appendChild(Utils.activateTemplate(templateRow, doc));
      }

      $(this.shadowRoot.querySelectorAll('#content > div'))
          .each((row, rowEl) => {
            for (let col = 0; col < colCount; col++) {
              let colEl = Utils.activateTemplate(templateCol, doc);
              $(colEl.querySelector('content'))
                  .attr('select', `[${ATTR_ROW}="${row}"][${ATTR_COL}="${col}"]`)
                  .attr(ATTR_ROW, row)
                  .attr(ATTR_COL, col);
              rowEl.appendChild(colEl);
            }
          });
    }

    /**
     * Returns the element at the given row and column, or null if not found.
     *
     * @method get
     * @param {number} row The row index of the element to be returned.
     * @param {number} col The col index of the element to be returned.
     * @return {HTMLElement|null} The HTML element at the given row and col, or null if not found.
     */
    get(row, col) {
      let contentEl = this.shadowRoot
          .querySelector(`content[${ATTR_ROW}="${row}"][${ATTR_COL}="${col}"]`);
      return contentEl ? contentEl.getDistributedNodes()[0] : null;
    }
  }

  Config.add(EL_NAME);
  $registry.add(EL_NAME, RectGrid.prototype);

  return RectGrid;

});
</script>
