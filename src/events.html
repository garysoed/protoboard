<base href="..">

<link rel="import" href="out/hammerwrapper.html">
<link rel="import" href="out/third_party/keypress.html">
<link rel="import" href="out/utils.html">

<script>
DI.bind('pb_Events', (HammerWrapper, Keypress, Utils) => {

  // Private symbols.
  const __element__ = Symbol();
  const __elementScopeMap__ = Symbol();
  const __registryRef__ = Symbol();
  const __scopeMap__ = Symbol();

  const __isRegistered__ = Symbol('isRegistered');
  const __register__ = Symbol('register');
  const __unregister__ = Symbol('unregister');

  const TYPES = {
    DOM: 'dom',
    HAMMER: 'hammer',
    JQUERY: 'jquery',
    KEYBOARD: 'keyboard'
  };

  const HANDLERS = {
    [TYPES.DOM]: {
      register: (action, eventName, handler) => {
        action[__element__].addEventListener(eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        action[__element__].removeEventListener(eventName, handler);
      }
    },

    [TYPES.HAMMER]: {
      register: (action, eventName, handler) => {
        HammerWrapper.on(action[__element__], eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        HammerWrapper.off(action[__element__], eventName, handler);
      }
    },

    [TYPES.JQUERY]: {
      register: (action, eventName, handler) => {
        $(action[__element__]).on(eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        $(action[__element__]).off(eventName, handler);
      }
    },

    [TYPES.KEYBOARD]: {
      __registryRef__: Symbol(),
      register: (action, eventName, handler) => {
        let ref = new Keypress();
        ref.simple_combo(eventName, handler);
        action[__element__][this[__registryRef__]] = ref;
      },
      unregister: (action, eventName, handler) => {
        action[__element__][this[__registryRef__]].stop_listening();
      }
    }
  };

  class Action {

    /**
     * Helper class for using {{#crossLink "Events"}}{{/crossLink}}.
     * @class Events.Action
     * @constructor
     * @param {Element} element Element to operate on.
     * @param {Object} scope Scope of the registered events.
     */
    constructor(element, scope) {
      this[__element__] = element;

      if (!this[__element__][__scopeMap__]) {
        this[__element__][__scopeMap__] = new Map();
      }

      if (!this[__element__][__scopeMap__].has(scope)) {
        this[__element__][__scopeMap__].set(scope, new Map());
      }

      this[__elementScopeMap__] = this[__element__][__scopeMap__].get(scope);
    }

    /**
     * @method __isRegistered__
     * @param {string} type The type of event to be checked.
     * @param {string} eventName Name of the event to be checked.
     * @private
     */
    [__isRegistered__](type, eventName) {
      if (!this[__elementScopeMap__].get(type)) {
        return false;
      }

      // TODO(gs): This check is too strict.
      return this[__elementScopeMap__].get(type).has(eventName);
    }

    /**
     * Registers the given handler to the given event name for the given type.
     *
     * @method __register__
     * @param {string} type The type of event to register the handler to.
     * @param {string} eventName Name of the event to register the handler to.
     * @param {Function} handler Handler to be called for the given event.
     * @return {Events} The Events object for chaining.
     * @private
     */
    [__register__](type, eventName, handler) {
      if (this[__isRegistered__](type, eventName)) {
        return this;
      }

      HANDLERS[type].register(this, eventName, handler);

      if (!this[__elementScopeMap__].has(type)) {
        this[__elementScopeMap__].set(type, new Map());
      }

      this[__elementScopeMap__].get(type).set(eventName, handler);
      return this;
    }

    /**
     * Unregisters the handlers in the scope for the element.
     *
     * - If only type and eventName are given, all handlers listening to that event name of that type
     *   will be unregistered.
     * - If only type is given, all handlers listening for that type will be unregistered.
     * - If nothing is given, all handlers in the scope will be unregistered.
     *
     * @method __unregister__
     * @param {string=} type Type of event to unregister.
     * @param {string=} eventName If given, all handlers listening to this event will be
     *     unregistered.
     * @return {!Events} The Events object for chaining.
     * @private
     */
    [__unregister__](type, eventName) {
      if (!type) {
        // Unregisters all events.
        for (let registeredType of this[__elementScopeMap__].keys()) {
          this[__unregister__](registeredType);
        }
        return this;
      }

      let typeMap = this[__elementScopeMap__].get(type);
      if (!typeMap) {
        return this;
      }

      if (!eventName) {
        // Unregisters all events of the given type.
        if (typeMap) {
          for (let event of typeMap.keys()) {
            this[__unregister__](type, event);
          }
        }
        return this;
      }

      let registeredEvent = typeMap.get(eventName);
      if (registeredEvent) {
        // Unregister the given event name.
        HANDLERS[type].unregister(
            this,
            eventName,
            registeredEvent);
        this[__elementScopeMap__].get(type).delete(eventName);
      }

      return this;
    }

    listen(eventName, handler) {
      return this[__register__](TYPES.DOM, eventName, handler);
    }

    unlisten(eventName) {
      return this[__unregister__](TYPES.DOM, eventName);
    }

    /**
     * Calls on method of the corresponding type on the element, registering the given event name
     * and handler.
     * TODO(gs): Make this customizable
     * @method on
     * @param {string} type The registration type.
     * @param {string} eventName Name of the event to register the handler to.
     * @param {Function} handler Handler to be called for the given event.
     * @return {Events.Action} The Action object for chaining.
     */
    on(type, eventName, handler) {
      if (arguments.length === 3) {
        return this[__register__](type, eventName, handler);
      } else {
        handler = eventName;
        eventName = type;

        // TODO: Remove this use
        return this[__register__](TYPES.JQUERY, eventName, handler);
      }
    }

    /**
     * Calls off method of the corresponding type on the element, unregistering the handlers in the
     * scope for the element.
     *
     * <ul>
     *   <li>If eventName is given, all handlers listening to that event name will be unlistened.
     *   <li>If nothing is given, all handlers in the scope will be unlistened.
     * </ul>
     *
     * @method off
     * @param {string} type The registration type.
     * @param {string} [eventName] If given, all handlers listening to this event will be
     *     unlistened.
     * @return {Events.Action} The Action object for chaining.
     */
    off(type, eventName) {
      return this[__unregister__](type, eventName);
    }
  }

  /**
   * Utility class to register / unregister events easily. This library handles 4 methods of
   * registrations:
   * - DOM
   * - <a href="http://hammerjs.github.io/">HammerJS</a>
   * - <a href="http://jquery.com/">JQuery</a>
   * - <a href="http://dmauro.github.io/Keypress/">Keypress</a>
   *
   * For a given scope object, only one handler can be bound to an event type.
   *
   * @example
   * var scope = {};
   *
   * // Register for events.
   * Events.of(element, scope)
   *     .on('dom', 'click', handleClick)        // Handles DOM click event.
   *     .on('hammer', 'tap', handleTap)         // Handles HammerJS tap event.
   *     .on('jquery', 'mouseup', handleMouseUp) // Handles mouseup event through JQuery.
   *     .on('keyboard', 'a', handleKeyA);       // Handles keypress a
   *
   * // Unregister events in the given scope.
   * Events.of(element, scope)
   *     .off('hammer')         // Unregisters all hammer events.
   *     .off('dom', 'click')   // Unregisters all DOM click events.
   *     .off();                // Unregisters all events in this scope.
   *
   * @class Events
   * @static
   */

  let Events = {
    /**
     * Creates an Events object that operates on the given element with the given scope.
     *
     * @method of
     * @param {Element} element The element to operate on.
     * @param {Object} scope Scope of the registered events.
     * @return {Events.Action} Chainable action object.
     * @static
     */
    of(element, scope) {
      return new Action(element, scope);
    }
  };

  if (window['TEST_MODE']) {
    Events.Action = Action;
  }

  return Events;
});
</script>