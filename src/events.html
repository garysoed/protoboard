<base href="..">

<link rel="import" href="out/hammerwrapper.html">
<link rel="import" href="out/third_party/keyboardjs.html">
<link rel="import" href="out/utils.html">

<script>
DI.bind('pb_Events', (HammerWrapper, KeyboardJS, Utils) => {

  // Private symbols.
  const __element__ = Symbol();
  const __elementScopeMap__ = Symbol();
  const __registryRef__ = Symbol();
  const __scopeMap__ = Symbol();

  const __isRegistered__ = Symbol('isRegistered');
  const __register__ = Symbol('register');
  const __unregister__ = Symbol('unregister');

  const TYPES = {
    DOM: 'dom',
    HAMMER: 'hammer',
    JQUERY: 'jquery',
    KEYBOARD: 'keyboard'
  };

  const HANDLERS = {
    [TYPES.DOM]: {
      register: (action, eventName, handler) => {
        action[__element__].addEventListener(eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        action[__element__].removeEventListener(eventName, handler);
      }
    },

    [TYPES.HAMMER]: {
      register: (action, eventName, handler) => {
        HammerWrapper.on(action[__element__], eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        HammerWrapper.off(action[__element__], eventName, handler);
      }
    },

    [TYPES.JQUERY]: {
      register: (action, eventName, handler) => {
        $(action[__element__]).on(eventName, handler);
      },
      unregister: (action, eventName, handler) => {
        $(action[__element__]).off(eventName, handler);
      }
    },

    [TYPES.KEYBOARD]: {
      __registryRef__: Symbol(),
      register: (action, eventName, handler) => {
        let ref = KeyboardJS.on(eventName, undefined, handler);
        action[__element__][this.__registryRef__] = ref;
      },
      unregister: (action, eventName, handler) => {
        action[__element__][this.__registryRef__].clear();
      }
    }
  };

  class Action {

    /**
     * @class Events.Action
     * @constructor
     * @param {!Element} element Element to operate on.
     * @param {!Object} scope Scope of the registered events.
     */
    constructor(element, scope) {
      this[__element__] = element;
      
      if (!this[__element__][__scopeMap__]) {
        this[__element__][__scopeMap__] = new Map();
      }

      if (!this[__element__][__scopeMap__].has(scope)) {
        this[__element__][__scopeMap__].set(scope, new Map());
      }

      this[__elementScopeMap__] = this[__element__][__scopeMap__].get(scope);
    }

    /**
     * @method __isRegistered__
     * @param {string} type The type of event to be checked.
     * @param {string} eventName Name of the event to be checked.
     * @private
     */
    [__isRegistered__](type, eventName) {
      if (!this[__elementScopeMap__].get(type)) {
        return false;
      }

      // TODO(gs): This check is too strict.
      return this[__elementScopeMap__].get(type).has(eventName);
    }

    /**
     * Registers the given handler to the given event name for the given type.
     *
     * @method __register__
     * @param {string} type The type of event to register the handler to.
     * @param {string} eventName Name of the event to register the handler to.
     * @param {!Function} handler Handler to be called for the given event.
     * @return {Events} The Events object for chaining.
     * @private
     */
    [__register__](type, eventName, handler) {
      if (this[__isRegistered__](type, eventName)) {
        return this;
      }

      HANDLERS[type].register(this, eventName, handler);

      if (!this[__elementScopeMap__].has(type)) {
        this[__elementScopeMap__].set(type, new Map());
      }

      this[__elementScopeMap__].get(type).set(eventName, handler);
      return this;
    }

    /**
     * Unregisters the handlers in the scope for the element.
     *
     * - If only type and eventName are given, all handlers listening to that event name of that type
     *   will be unregistered.
     * - If only type is given, all handlers listening for that type will be unregistered.
     * - If nothing is given, all handlers in the scope will be unregistered.
     *
     * @method __unregister__
     * @param {string=} type Type of event to unregister.
     * @param {string=} eventName If given, all handlers listening to this event will be 
     *     unregistered.
     * @return {!Events} The Events object for chaining.
     * @private
     */
    [__unregister__](type, eventName) {
      if (!type) {
        // Unregisters all events.
        for (let registeredType of this[__elementScopeMap__].keys()) {
          this[__unregister__](registeredType);
        }
        return this;
      }

      let typeMap = this[__elementScopeMap__].get(type);
      if (!typeMap) {
        return this;
      }

      if (!eventName) {
        // Unregisters all events of the given type.
        if (typeMap) {
          for (let event of typeMap.keys()) {
            this[__unregister__](type, event);
          }
        }
        return this;
      }

      let registeredEvent = typeMap.get(eventName);
      if (registeredEvent) {
        // Unregister the given event name.
        HANDLERS[type].unregister(
            this, 
            eventName, 
            registeredEvent);
        this[__elementScopeMap__].get(type).delete(eventName);
      }

      return this;
    }

    /**
     * Calls addEventListener to the element, registering the given event name and handler.
     *
     * @method listen
     * @param {string} eventName Name of the event to register the handler to.
     * @param {!Function} handler Handler to be called for the given event.
     * @return {Events} The Events object for chaining.
     */
    listen(eventName, handler) {
      return this[__register__](TYPES.DOM, eventName, handler);
    }

    /**
     * Calls removeEventListener to the element, unregistering the handlers in the scope for the 
     * element.
     *
     * - If eventName and handler are given, only the handler listening to that event will be 
     *   unlistened.
     * - If only eventName is given, all handlers listening to that event name will be unlistened.
     * - If nothing is given, all handlers in the scope will be unlistened.
     *
     * @method unlisten
     * @param {string=} eventName If given, all handlers listening to this event will be 
     *     unlistened.
     * @return {!Events} The Events object for chaining.
     */
    unlisten(eventName) {
      return this[__unregister__](TYPES.DOM, eventName);
    }

    /**
     * @method hasListener
     * @param {string} eventName Name of the event to be checked.
     * @param {Function=} handler The function to be checked.
     */
    hasListener(eventName) {
      return this[__isRegistered__](TYPES.DOM, eventName);
    }

    /**
     * Calls on method of the corresponding type on the element, registering the given event name 
     * and handler. 
     * TODO(gs): Make this customizable
     * @method on
     * @param {string} type The registration type.
     * @param {string} eventName Name of the event to register the handler to.
     * @param {!Function} handler Handler to be called for the given event.
     * @return {!Events} The Events object for chaining.
     */
    on(type, eventName, handler) {
      if (arguments.length === 3) {
        return this[__register__](type, eventName, handler);
      } else {
        handler = eventName;
        eventName = type;

        // TODO: Remove this use
        return this[__register__](TYPES.JQUERY, eventName, handler);
      }
    }

    /**
     * Calls off method of the corresponding type on the element, unregistering the handlers in the 
     * scope for the element.
     *
     * - If eventName is given, all handlers listening to that event name will be unlistened.
     * - If nothing is given, all handlers in the scope will be unlistened.
     *
     * @method off
     * @param {string} type The registration type.
     * @param {string=} eventName If given, all handlers listening to this event will be 
     *     unlistened.
     * @return {!Events} The Events object for chaining.
     */
    off(type, eventName) {
      if (arguments.length === 3) {
        return this[__unregister__](type, eventName);
      } else {
        eventName = type;

        // TODO: Remove this use
        return this[__unregister__](TYPES.JQUERY, eventName);
      }
    }
  }

  /**
   * Utility class to register / unregister events easily.
   *
   * @class Events
   * @static
   */

  let Events = {
    /**
     * Creates an Events object that operates on the given element with the given scope.
     *
     * @method of
     * @param  {!Element} element The element to operate on.
     * @param  {!Object} scope Scope of the registered events.
     * @return {!Events} Chainable Events object.
     * @static
     */
    of(element, scope) {
      return new Action(element, scope);
    }
  };

  if (window['TEST_MODE']) {
    Events.Action = Action;
  }

  return Events;
});
</script>