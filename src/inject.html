<base href="..">

<script>
(() => {

// Private symbols.
const __key__ = Symbol();
const __localValues__ = Symbol();
const __providerFn__ = Symbol();
const __value__ = Symbol();

const __resolveKey__ = Symbol();
const __getRegistered__ = Symbol();

const FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;

const providers = {};

/**
 * TODO(gs): Document this.
 * @class Inject.Provider
 */
class Provider {

  constructor(providerFn, key, localValues) {
    this[__value__] = null;
    this[__key__] = key || null;
    this[__providerFn__] = providerFn;
    this[__localValues__] = localValues || {};

    if (key) {
      providers[key] = this;
    }
  }

  inject() {
    let argsString = this[__providerFn__].toString().match(FN_ARGS)[1];
    let args = argsString ? argsString.split(',') : [];
    let resolvedArgs = args.map((arg) => {
      let arg = arg.trim();
      let value = Inject[__resolveKey__](arg, this[__localValues__]);

      if (value === undefined) {
        value = Inject.get(arg);
      }

      if (value === undefined) {
        throw `Cannot find ${arg} while providing ${this[__key__]}`;
      } 

      return value;
    });

    this[__value__] = this[__providerFn__].apply(null, resolvedArgs);

    if (this[__value__] === undefined && this[__key__]) {
      console.warn(`Value of ${this[__key__]} is undefined`);
    }
  }

  /**
   * Bind the given value to the given binding key.
   * TODO(gs): Make this look like Inject.with
   *
   * @param {string} key The binding key to use.
   * @param {*} value The value to be bound.
   * @return {Inject.Provider} The provider to be chained.
   */
  with(key, value) {
    let localValues = {};
    for (let localKey in this[__localValues__]) {
      localValues[localKey] = this[__localValues__][localKey];
    }
    localValues[key] = value;
    return new Provider(this[__providerFn__], this[__key__], localValues);
  }
}

/**
 * Provides dependency injection. The main way to use this is to call the #provide method.
 *
 * ```javascript
 * Inject.provide('test_Object', function(a, b) {
 *   return {};
 * });
 * ```
 *
 * Each object provided is associated with an binding key. This key is used as argument name for
 * providing functions. In the example above, the library will inject objects with binding key 'a'
 * and 'b' to the function. The function needs to return the object that should be provided.
 *
 * A binding key is namespaced by underscores. This allows you to refer an binding key through
 * different way. For example, an object with 'a_b_c' can be referred by 'c', 'b_c', or 'a_b_c'.
 * 
 * @class Inject
 * @static
 */

let Inject = {

  [__resolveKey__](key, providers) {
    // Full path.
    if (providers[key]) {
      return providers[key];
    }

    // Otherwise, check for the postfix.
    for (let existingKey in providers) {
      let index = existingKey.indexOf(key, existingKey.length - key.length);
      if (index >= 0 && (index === 0 || existingKey[index - 1] === '_')) {
        return providers[existingKey];
      }
    }

    return undefined;
  },

  /**
   * Binds the result of the given function to the given key.
   *
   * @method provide
   * @param {string} key The binding key.
   * @param {!Function} providerFn The function that returns the value to be bound.
   */
  provide(key, providerFn) {
    (new Provider(providerFn, key)).inject();
  },

  /**
   * Runs the given function with injected values.
   *
   * @method inject
   * @param {!Function} providerFn The function to run.
   */
  inject(providerFn) {
    (new Provider(providerFn)).inject();
  },

  /**
   * Binds additional values for providing a value. These values will only be bound for this 
   * instance of provider.
   *
   * @method with
   * @param {!Object} localValues Object whose key is the binding key and value is the value to be
   *    bound to that key.
   * @return {!Object} Object with the provide function and with function. See documentations on
   *    those methods.
   */
  with(key, value) {
    let localValues = {};
    localValues[key] = value;
    return {
      with(key, value) {
        localValues[key] = value;
        return this;
      },

      provide(key, providerFn) {
        (new Provider(providerFn, key, localValues)).inject();
      },

      inject(providerFn) {
        (new Provider(providerFn, null, localValues)).inject();
      }
    };
  },

  /**
   * @param {string} key The binding key of the value to return.
   * @return {*} The bound value, or undefined if no values were bound.
   */
  get(key) {
    let registered = this[__resolveKey__](key, providers);
    return registered !== undefined ? registered[__value__] : undefined;
  },

  /**
   * @param {string} key The binding key of the provider to return.
   * @return {Inject.Provider} The bound provider object, or undefined if no providers were bound.
   */
  getProvider(key) {
    return this[__resolveKey__](key, providers);
  }
};

window['Inject'] = Inject;

})();
</script>
