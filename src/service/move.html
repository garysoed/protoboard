<base href="..">

<link rel="import" href="service/registry.html">
<link rel="import" href="third_party/di.html">

<style>
  .pb-move {
    filter: drop-shadow(var(--drop-shadow-layer-1));
    opacity: 0.75;
    position: fixed;
    pointer-events: none;
  }

  .pb-move > * {
    position: absolute;
  }

  .pb-move > *:nth-child(2) {
    transform: rotateZ(-20deg);
  }

  .pb-move > *:nth-child(3) {
    transform: rotateZ(15deg);
  }

  .pb-move > *:nth-child(4) {
    transform: rotateZ(-35deg);
  }

  .pb-move > *:nth-child(5) {
    transform: rotateZ(40deg);
  }
</style>

<script>
DI
    .prefix('pb')
    .bind('service.Move', { $registry: '=', Events: '=', Utils: '=' }, $i => {

  // Private symbols.
  const __container__ = Symbol('container');
  const __document__ = Symbol();
  const __mouseX__ = Symbol();
  const __mouseY__ = Symbol();

  const __moveContainer__ = Symbol('moveContainer');
  const __onMouseMove__ = Symbol('onMouseMove');

  /**
   * Service that handles moving elements around. Used by
   * {{#crossLink "ability.Droppable"}}{{/crossLink}} and
   * {{#crossLink "ability.Pickable"}}{{/crossLink}}.
   *
   * ```javascript
   * Move.add(element);  // Sets the element as moved.
   *
   * // The element will be moved to a special container. To remove the element, just append it
   * // somewhere else.
   * ```
   *
   * @class service.Move
   * @static
   */
  let Move = {
    /**
     * Reference to the document that the service operates in.
     *
     * @property __document__
     * @type Document
     * @private
     */
    [__document__]: undefined,

    /**
     * The container of all the moved elements.
     *
     * @property __container__
     * @type Element
     * @private
     */
    [__container__]: null,

    /**
     * Moves the container element to the last known location of the mouse.
     *
     * @method __moveContainer__
     * @private
     */
    [__moveContainer__]() {
      let width = 0;
      let height = 0;
      $i.Utils.toArray(this[__container__].children).forEach(child => {
        let rect = child.getBoundingClientRect();
        width = Math.max(rect.width, width);
        height = Math.max(rect.height, height);
      });

      this[__container__].style.left = `${this[__mouseX__] - width / 2}px`;
      this[__container__].style.top = `${this[__mouseY__] - height / 2}px`;
    },

    /**
     * Handles event when the mouse is moved.
     *
     * @method __onMouseMove__
     * @param {MouseEvent} event The corresponding mouse event.
     * @private
     */
    [__onMouseMove__](event) {
      this[__moveContainer__]();
      this[__mouseX__] = event.clientX;
      this[__mouseY__] = event.clientY;
    },

    /**
     * Sets the given element as being moved.
     *
     * @method add
     * @param {Element} el Element to move.
     */
    add(el) {
      this[__container__].appendChild(el);
      this[__moveContainer__]();
    },

    /**
     * The elements that are being moved.
     *
     * @property movedElements
     * @type Set
     * @final
     */
    get movedElements() {
      return new Set($i.Utils.toArray(this[__container__].children));
    },

    /**
     * Last known X coordinate of the mouse in px.
     *
     * @property mouseX
     * @type number
     * @final
     */
    get mouseX() {
      return this[__mouseX__];
    },

    /**
     * Last known Y coordinate of the mouse in px.
     *
     * @property mouseY
     * @type number
     * @final
     */
    get mouseY() {
      return this[__mouseY__];
    }
  };

  $i.$registry.runAtRegister(doc => {
    $i.Events.of(doc.body, Move)
        .on('dom', 'mousemove', Move[__onMouseMove__].bind(Move));
    Move[__document__] = doc;
    Move[__container__] = doc.createElement('div');
    Move[__container__].classList.add('pb-move');
    doc.body.appendChild(Move[__container__]);
  });

  return Move;
});
</script>
