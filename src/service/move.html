<base href="..">

<link rel="import" href="pbelement.html">
<link rel="import" href="service/config.html">
<link rel="import" href="service/registry.html">
<link rel="import" href="third_party/di.html">
<link rel="import" href="third_party/jquery.html">

<style>
  pb-s-move {
    filter: drop-shadow(var(--drop-shadow-layer-1));
    opacity: 0.75;
    position: fixed;
    pointer-events: none;
  }

  pb-s-move > * {
    position: absolute;
  }

  pb-s-move > *:nth-child(2) {
    transform: rotateZ(-20deg);
  }

  pb-s-move > *:nth-child(3) {
    transform: rotateZ(15deg);
  }

  pb-s-move > *:nth-child(4) {
    transform: rotateZ(-35deg);
  }

  pb-s-move > *:nth-child(5) {
    transform: rotateZ(40deg);
  }
</style>

<script>
DIJS
    .prefix('pb')
    .bind('service.Move', require => {

  const $ = require('/$');
  const $registry = require('$registry');
  const Config = require('service.Config');
  const Events = require('Events');
  const PbElement = require('PbElement');
  const Utils = require('Utils');

  const EVENT_MOVE = 'move';
  const EL_NAME = 'pb-s-move';

  // Private symbols.
  const __container__ = Symbol('container');
  const __height__ = Symbol();
  const __mouseX__ = Symbol();
  const __mouseY__ = Symbol();
  const __width__ = Symbol();

  const __moveContainer__ = Symbol('moveContainer');
  const __onMouseMove__ = Symbol('onMouseMove');
  const __onContainerMutation__ = Symbol('onContainerMutation');

  const __origin__ = Symbol();

  /**
   * Service that handles moving elements around. Used by
   * {{#crossLink "ability.Droppable"}}{{/crossLink}} and
   * {{#crossLink "ability.Pickable"}}{{/crossLink}}.
   *
   * ```javascript
   * Move.add(element);  // Sets the element as moved.
   *
   * // The element will be moved to a special container. To remove the element, just append it
   * // somewhere else.
   * ```
   *
   * @class service.Move
   * @static
   */
  let Move = {

    /**
     * The container of all the moved elements.
     *
     * @property __container__
     * @type Element
     * @private
     */
    [__container__]: null,

    /**
     * Moves the container element to the last known location of the mouse.
     *
     * @method __moveContainer__
     * @private
     */
    [__moveContainer__]() {
      let width = 0;
      let height = 0;
      Utils.toArray(this[__container__].children).forEach(child => {
        if (!child[__width__] || !child[__height__]) {
          let rect = child.getBoundingClientRect();
          child[__height__] = Math.max(rect.height, height);
          child[__width__] = Math.max(rect.width, width);
        }
        height = child[__height__];
        width = child[__width__];
      });

      this[__container__].style.left = `${this[__mouseX__] - width / 2}px`;
      this[__container__].style.top = `${this[__mouseY__] - height / 2}px`;
    },

    /**
     * Handles event when the mouse is moved.
     *
     * @method __onMouseMove__
     * @param {MouseEvent} event The corresponding mouse event.
     * @private
     */
    [__onMouseMove__](event) {
      this[__moveContainer__]();
      this[__mouseX__] = event.clientX;
      this[__mouseY__] = event.clientY;
    },

    /**
     * Handles event when there is a mutation on the container element.
     *
     * @method __onContainerMutation__
     * @param {Array} records Array of mutation records.
     * @private
     */
    [__onContainerMutation__](records) {
      for (let record of records) {
        Utils.toArray(record.removedNodes).forEach(removedNode => {
          if (removedNode[__origin__] && removedNode[__origin__] !== removedNode.parentElement) {
            $(this).trigger(
                this.Events.MOVE,
                {
                  moved: removedNode,
                  from: removedNode[__origin__],
                  to: removedNode.parentElement
                });
          }
        });
      }
    },

    /**
     * Sets the given element as being moved.
     *
     * @method add
     * @param {Element} el Element to move.
     */
    add(el) {
      el[__height__] = undefined;
      el[__width__] = undefined;
      el[__origin__] = el.parentElement;
      this[__container__].appendChild(el);
      this[__moveContainer__]();
    },

    /**
     * The elements that are being moved.
     *
     * @property movedElements
     * @type Set
     * @final
     */
    get movedElements() {
      return new Set(Utils.toArray(this[__container__].children));
    },

    /**
     * The next element to be moved.
     *
     * @property nextElement
     * @type Element
     * @final
     */
    get nextElement() {
      return this[__container__].lastElementChild;
    },

    /**
     * Last known X coordinate of the mouse in px.
     *
     * @property mouseX
     * @type number
     * @final
     */
    get mouseX() {
      return this[__mouseX__];
    },

    /**
     * Last known Y coordinate of the mouse in px.
     *
     * @property mouseY
     * @type number
     * @final
     */
    get mouseY() {
      return this[__mouseY__];
    },

    /**
     * Events that this class can trigger.
     * - `MOVE`: Called when an element has been moved.
     *
     * @property Events
     * @type Object
     * @final
     */
    get Events() {
      return {
        get MOVE() { return 'move'; }
      };
    }
  };

  class MoveElement extends PbElement { }

  Config.add(EL_NAME);
  $registry.add(EL_NAME, MoveElement);
  $registry.runAtRegister(doc => {
    Events.of(doc.body, Move)
        .on('dom', 'mousemove', Move[__onMouseMove__].bind(Move));
    Move[__container__] = doc.createElement(EL_NAME);
    doc.body.appendChild(Move[__container__]);

    let observer = new MutationObserver(Move[__onContainerMutation__].bind(Move));
    observer.observe(Move[__container__], { childList: true });
  });

  return Move;
});
</script>
