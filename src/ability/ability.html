<base href="..">

<link rel="import" href="check.html">
<link rel="import" href="service/log.html">
<link rel="import" href="third_party/di.html">
<link rel="import" href="third_party/jquery.html">
<link rel="import" href="trigger/triggers.html">
<link rel="import" href="utils.html">

<script>
DI
    .bind('CustomEvent', {}, () => CustomEvent)
    .prefix('pb')
    .bind(
        'ability.Ability',
        {
          $: '/=',
          Check: '=',
          CustomEvent: '/=',
          Log: 'service.=',
          Triggers: 'trigger.='
        },
        $i => {

  // Private symbols.
  const __name__ = Symbol();
  const __defaultTrigger__ = Symbol('defaultTrigger');
  const __triggerMap__ = Symbol('triggerMap');

  /**
   * Base class for all abilities. Any abilities must extend this class and implement the methods
   * in this class.
   *
   * Since `v1.1.0`, all abilities extending this class will trigger an event with the same name as
   * this ability's name when triggered. This event's detail will have one field, called ability,
   * which is a reference to this ability.
   *
   * Since `v1.2.0`, all abilities will log its triggering before and after it is triggered. In the
   * entry passed into the preprocessor or the printer, you can examine the value of the `phase`
   * entry. If it is `bubble`, the log is called before the trigger is ran. Otherwise, if it is
   * `after`, the log is called after the trigger is ran.
   *
   * @class ability.Ability
   */
  class Ability {

    /**
     * @constructor
     * @class ability.Ability
     * @param {string} name Name of the ability. This is used to identify an ability that has been
     *    added to an element. It therefore must be unique for the element.
     * @param {trigger.Trigger} [defaultTrigger] The default trigger to trigger this ability, or
     *    null if there are no default triggers.
     */
    constructor(name, defaultTrigger) {
      this[__name__] = name;
      this[__defaultTrigger__] = defaultTrigger || null;
    }

    /**
     * Initializes the ability on the given element.
     *
     * @method init
     * @param {Element} el The element to set the default values to.
     */
    init(el) {
      if ($i.$(el).attr(this.attrTrigger) === undefined && this[__defaultTrigger__]) {
        $i.$(el).attr(this.attrTrigger, this[__defaultTrigger__].toString());
      }

      this.updateConfig(el);
    }

    /**
     * Updates the inner state of the ability based on changes to the element.
     *
     * @method updateConfig
     * @param {Element} el Element whose attributes have changed.
     */
    updateConfig(el) {
      if (!el[__triggerMap__]) {
        el[__triggerMap__] = new Map();
      }

      let newValue = $i.$(el).attr(this.attrTrigger);
      if (!el[__triggerMap__].has(this)
          || newValue !== el[__triggerMap__].get(this).toString()) {
        if (el[__triggerMap__].has(this)) {
          el[__triggerMap__].get(this).off(el);
        }
        let trigger = $i.Triggers.parse($i.$(el).attr(this.attrTrigger));

        if (trigger) {
          trigger.on(el, this);
        }
        el[__triggerMap__].set(this, trigger);
      }
    }

    /**
     * Triggers the effect of the ability on the given element.
     *
     * @method trigger
     * @param {Element} el The element to trigger the ability on.
     */
    trigger(el) {
      if (this.isEnabled(el)) {
        $i.Log.log(this.attrName, $i.$(el).attr('pb-id'), { phase: 'before' });
        this.doTrigger(el);
        el.dispatchEvent(new $i.CustomEvent(
            this.attrName,
            {
              detail: {
                ability: this
              }
            }));
        $i.Log.log(this.attrName, $i.$(el).attr('pb-id'), { phase: 'after' });
      }
    }

    /**
     * Actually triggers the effect of the ability on the given element. All abilities must extend
     * this method.
     *
     * @method doTrigger
     * @param {Element} el The element to trigger the ability on.
     */
    doTrigger(el) {
      throw new Error('Unimplemented');
    }

    /**
     * Returns the trigger for this ability on this element.
     *
     * @method getTrigger
     * @param {Element} el The element to return the trigger for this ability for.
     * @return {trigger.Trigger|null} The trigger for this ability on this element, or null if there
     *    is none.
     */
    getTrigger(el) {
      return el[__triggerMap__] ? el[__triggerMap__].get(this) : null;
    }

    /**
     * @method isEnabled
     * @param {Element} el The element to check if the ability is enabled on it.
     * @return {Boolean} True iff the ability is enabled on the given element.
     */
    isEnabled(el) {
      return $i.Check($i.$(el).attr(this.attrName)).isBoolean().orUse(false);
    }

    /**
     * Name of the ability. This is also the name of the attribute on the element corresponding to
     * this ability.
     *
     * @property attrName
     * @type string
     * @final
     */
    get attrName() {
      return this[__name__];
    }

    /**
     * The name of the attribute on the element corresponding to this ability that sets the trigger
     * for this ability. This is the name of the ability with a `-on` postfix.
     *
     * @property attrTrigger
     * @type string
     * @final
     */
    get attrTrigger() {
      return `${this[__name__]}-on`;
    }

    /**
     * The default trigger of the ability, or null if none exists.
     *
     * @property defaultTrigger
     * @type trigger.Trigger
     */
    get defaultTrigger() {
      return this[__defaultTrigger__];
    }
    set defaultTrigger(defaultTrigger) {
      this[__defaultTrigger__] = defaultTrigger;
    }
  }

  return Ability;
});
</script>
