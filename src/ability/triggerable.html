<base href="../..">

<link rel="import" href="out/ability/ability.html">
<link rel="import" href="out/hammerwrapper.html">
<link rel="import" href="out/di.html">
<link rel="import" href="out/trigger/click.html">
<link rel="import" href="out/trigger/doubleclick.html">
<link rel="import" href="out/trigger/key.html">
<link rel="import" href="out/utils.html">

<script>
DI.bind('pb_ability_Triggerable', (Ability, Click, DoubleClick, HammerWrapper, Key, Utils) => {

  /**
   * Provides triggers to abilities supported by the app. Normally you don't need to register this 
   * to the app. [[ability.Abilities|ability.Abilities]] should do this for you.
   *
   * To use this class, add the trigger as an attribute name, and the name of the ability as its 
   * value.
   *
   * Supported triggers:
   * - `pb-click`: Triggers when the element is clicked.
   * - `pb-dblclick`: Triggers when the element is double clicked.
   * 
   * @class ability.Triggerable
   * @extends ability.Ability
   */

  // Private symbols.
  const __defaultValue__ = Symbol();
  const __keys__ = Symbol();
  const __knownAbilities__ = Symbol();

  const __getTrigger__ = Symbol('getTrigger');
  const __register__ = Symbol('register');
  const __unregister__ = Symbol('unregister');

  const TYPES = {
    /**
     * Triggers when the element is clicked.
     *
     * @attribute pb-click
     */
    CLICK: 'pb-click',

    /**
     * Triggers when the element is double clicked.
     *
     * @attribute pb-dblclick
     */
    DOUBLE_CLICK: 'pb-dblclick',

    /**
     * Triggers when a key is pressed. Postfix this with `-` followed by the character to detect.
     *
     * @attribute pb-key
     */
    KEY: 'pb-key'
  };

  const TRIGGERS = {
    [TYPES.CLICK]: new Click(),
    [TYPES.DOUBLE_CLICK]: new DoubleClick(),
    [TYPES.KEY]: new Key()
  };

  const KEYS = new Map();

  class Triggerable extends Ability {

    /**
     * @class ability.Triggerable
     * @constructor
     * @param {Object=} defaultValue An object with the triggerable type string as the key, and 
     *     the triggered ability's name as the value. These keys correspond to the element's 
     *     attributes. Defaults to empty object.
     * @param {Array.<ability.Ability>=} knownAbilities A list of known abilities. This is used 
     *     when the element's attribute value is changed. Defaults to empty array.
     */
    constructor(defaultValue = {}, knownAbilities = []) {
      this[__defaultValue__] = defaultValue;
      this[__knownAbilities__] = {};
      for (let ability of knownAbilities) {
        this[__knownAbilities__][ability.constructor.name] = ability;
      }
    }

    /**
     * Returns the trigger object that corresponds to the given name.
     *
     * @method __getTrigger__
     * @param {string} name The name of the trigger to return.
     * @return {trigger.Trigger} The corresponding trigger object to return, or null if there is no 
     *    corresponding trigger.
     */
    [__getTrigger__](name) {
      if (name !== TYPES.KEY && TRIGGERS[name]) {
        return TRIGGERS[name];
      } else if (name.substring(0, TYPES.KEY.length + 1) === (TYPES.KEY + '-')) {
        let key = name.substring(TYPES.KEY.length + 1);
        if (!key) {
          return null;
        }
        if (!KEYS.has(key)) {
          KEYS.set(key, TRIGGERS[TYPES.KEY](key));
        }
        return KEYS.get(key);
      } else {
        return null;
      }
    }

    /**
     * Registers the given element to trigger the given ability.
     *
     * @method  __register__
     * @param {!Element} el The element to register.
     * @param {!trigger.Trigger} trigger The trigger to register.
     * @param {ability.Ability} ability The ability to register.
     * @private
     */
    [__register__](el, trigger, ability) {
      trigger.on(el, ability);
    }

    /**
     * Unregisters the given trigger type from the element.
     *
     * @method __unregister__
     * @param {!Element} el The element to unregister from.
     * @param {!trigger.Trigger} trigger The trigger to unregister.
     * @private
     */
    [__unregister__](el, trigger) {
      trigger.off(el);
    }

    /**
     * Sets the default value of the given element.
     *
     * @method setDefaultValue
     * @param {!Element} el The element whose default value should be set.
     */
    setDefaultValue(el) {
      for (let key in TYPES) {
        let type = TYPES[key]; 
        let abilityName = this[__defaultValue__][type];
        let trigger = this[__getTrigger__](type);
        if (trigger
            && $(el).attr(type) === undefined 
            && abilityName 
            && this[__knownAbilities__][abilityName]) {
          $(el).attr(type, abilityName);
        }
      }
    }

    /**
     * Handles attribute change.
     *
     * @method attributeChangedCallback
     * @param {!Element} el The element whose attribute was changed.
     * @param {string} name Name of the attribute that was changed.
     * @param {string} oldValue Old value of the changed attribute.
     * @param {string} newValue New value of the changed attribute.
     */
    attributeChangedCallback(el, name, oldValue, newValue) {
      let trigger = this[__getTrigger__](name);
      if (trigger) {
        // Unregister the old ability.
        if (oldValue && this[__knownAbilities__][oldValue]) {
          this[__unregister__](el, trigger);
        }

        if (newValue && this[__knownAbilities__][newValue]) {
          this[__register__](el, trigger, this[__knownAbilities__][newValue]);
        }
      }
    }

    /**
     * Called when the element is attached to the document.
     *
     * @method attachedCallback
     * @param {!Element} el The element that was attached.
     */
    attachedCallback(el) {
      for (let [name, attr] of Utils.toMap(el.attributes)) {
        let abilityName = attr.value;
        let trigger = this[__getTrigger__](name);
        if (trigger && abilityName && this[__knownAbilities__][abilityName]) {
          this[__register__](el, trigger, this[__knownAbilities__][abilityName]);
        }
      }
    }

    /**
     * Called when the element is detached from the document.
     *
     * @method detachedCallback
     * @param {!Element} el The element that was detached.
     */
    detachedCallback(el) {
      for (let key in TYPES) {
        let trigger = this[__getTrigger__](TYPES[key]);
        if (trigger) {
          this[__unregister__](el, trigger);
        }
      }

      for (let trigger of KEYS.values()) {
        this[__unregister__](el, trigger);
      }
    }

    /**
     * The name of the ability. This is used as an ID to refer to the registered abilities.
     * 
     * @property name
     * @type string
     * @readonly
     */
    get name() {
      return 'pb-triggerable';
    }
  }

  Triggerable.TYPES = TYPES;

  return Triggerable;
});
