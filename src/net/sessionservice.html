<base href="..">

<link rel="import" href="net/rpcservice.html">
<link rel="import" href="net/sync.html">
<link rel="import" href="net/utils.html">
<link rel="import" href="data/stateservice.html">
<link rel="import" href="ui/templateservice.html">
<link rel="import" href="third_party/di.html">
<link rel="import" href="third_party/events.html">

<script>
DIJS
.bind('pb.net.SessionService.__ctor__', require => {

  const Events = require('pb.Events');
  const Sync = require('pb.net.Sync');

  const __checkPlayers__ = Symbol();
  const __rootSync__ = Symbol();

  class Service {

    /**
     * Service that manages game session.
     *
     * @constructor
     * @param {net.Sync} rootSync Sync object of the root.
     * @class net.SessionService
     */
    constructor(rootSync) {
      this[__rootSync__] = rootSync;
    }

    /**
     * Checks if there are enough players in the game.
     *
     * @method __checkPlayers__
     * @param {net.Sync} gameSync Game sync object to check if there are enough players.
     * @param {Function} callback Function called when there are enough players in the game.
     * @private
     */
    [__checkPlayers__](gameSync, callback) {
      gameSync.get()
          .then(game => {
            if (game.playerCount <= Object.keys(game.players).length) {
              Events.of(gameSync, this).off('jquery', Sync.Events.UPDATED);
              callback();
            }
          });
    }

    /**
     * Creates a new game.
     *
     * @method create
     * @param {number} playerCount Number of players required for this game.
     * @param {Object} initialState Initial state of the game. Defaults to empty object.
     * @return {Promise} Promise that will be resolved with the game sync object when the game has
     *    been created.
     */
    create(playerCount, initialState = {}) {
      return this[__rootSync__].add()
          .then(gameSync => {
            return gameSync.set({
              playerCount: playerCount,
              players: [],
              state: initialState
            });
          });
    }

    /**
     * @method get
     * @param {string} gameId ID of the game sync object to return.
     * @return {net.Sync} The game sync object with the given ID.
     */
    get(gameId) {
      return this[__rootSync__].sync(gameId);
    }

    /**
     * Joins the given game.
     *
     * @method join
     * @param {string} gameSync Game sync object to join.
     * @param {string} id Display name of the player joining the game.
     * @param {Object} state The initial state of the player joining the game.
     * @return {Promise} Promise that will be resolved with the game sync when the join is
     *    successful.
     */
    join(gameSync, id, state = {}) {
      let playersSync = gameSync.sync('players');
      return playersSync
          .add()
          .then(playerSync => {
            return playerSync.set({
              id: id,
              state: state
            });
          })
          .then(() => {
            return gameSync;
          });
    }

    /**
     * Waits the game to have enough players, then start it.
     *
     * @method start
     * @param {string} gameId ID of the game to start.
     * @return {Promise} Promise that will be resolved with the game sync object when the game has
     *    enough players.
     */
    start(gameSync) {
      return new Promise((resolve, reject) => {
        let boundResolve = resolve.bind(null, gameSync);
        Events.of(gameSync, this).on(
            'jquery',
            Sync.Events.UPDATED,
            this[__checkPlayers__].bind(this, gameSync, boundResolve));
        this[__checkPlayers__](gameSync, boundResolve);
      });
    }
  }

  return Service;
})
.bind('pb.net.SessionService', require => {
  const SessionService = require('pb.net.SessionService.__ctor__');
  const Sync = require('pb.net.Sync');
  return new SessionService(new Sync('(root)', '/'));
});
</script>
