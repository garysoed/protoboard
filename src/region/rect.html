<base href="../..">

<link rel="import" href="out/ability/abilities.html">
<link rel="import" href="out/ability/droppable.html">
<link rel="import" href="out/di.html">
<link rel="import" href="out/region/region.html">
<link rel="import" href="out/service/dragdrop.html">
<link rel="import" href="out/trigger/click.html">
<link rel="import" href="out/trigger/key.html">
<link rel="import" href="out/utils.html">

<link rel="stylesheet" type="text/css" href="out/region/rect.css">

<template>
  <div id="root">
    <content></content>
  </div>
</template>

<script>
DI
    .constant('doc', document.currentScript.ownerDocument)
    .with('template', doc => doc.querySelector('template'))
    .bind('pb_region_Rect', (
        $registry,
        Abilities,
        Click,
        DragDrop, 
        Droppable, 
        Key,
        Region, 
        Utils, 
        doc, 
        template) => {
  const EL_NAME = 'pb-r-rect';

  // Private symbols
  const __mutationObserver__ = Symbol('mutationObserver');
  const __onDomMutation__ = Symbol('onDomMutation');

  /**
   * An arbitrary rectangular region. You can position elements anywhere in this region.
   *
   * Supported abilities:
   * - [[Droppable|ability.Droppable]]: Default enabled. This class uses a custom droppable that 
   *   positions the element to the mouse's cursor.
   *   
   * @class region.Rect
   * @extends region.Region
   */

  class FlexDroppable extends Droppable {

    /**
     * @constructor
     * @class region.Rect
     * @param {string} [name='pb-droppable'] Name of the ability.
     * @param {trigger.Trigger} [defaultTrigger=trigger.Click] Default trigger for the ability.
     * @param {boolean} [defaultEnabled=true] True iff the ability should be enabled by default.
     */
    constructor(name = 'pb-droppable', defaultTrigger = new Click(), defaultEnabled = true) {
      super(name, defaultTrigger, defaultEnabled);
      this[__mutationObserver__] = new MutationObserver(this[__onDomMutation__].bind(this));
    }

    /**
     * Handles event when the MutationObserver observes changes to the child list.
     *
     * @method __onDomMutation__
     * @param {!Array.<MutationRecord>} mutations Array of MutationRecords.
     * @private
     */
    [__onDomMutation__](mutations) {
      mutations.forEach(mutation => {
        Utils.toArray(mutation.removedNodes).forEach(removedNode => {
          removedNode.style.left = 0;
          removedNode.style.top = 0;
        });
      });
    }

    /**
     * Drop the last dragged element on the given element
     *
     * @method trigger
     * @param {!Element} el The element to drop the dragged element into.
     * @param {!Event} event Event object that triggered the call.
     */
    trigger(el, event) {
      let lastDraggedEl = DragDrop.lastDraggedEl;
      if (!lastDraggedEl) {
        return;
      }
      el.appendChild(lastDraggedEl);

      let screenCoord = lastDraggedEl.getBoundingClientRect();
      let dLeft = event.clientX - screenCoord.left - DragDrop.offsetX;
      let dTop = event.clientY - screenCoord.top - DragDrop.offsetY;
      lastDraggedEl.style.left = `${lastDraggedEl.offsetLeft + dLeft}px`;
      lastDraggedEl.style.top = `${lastDraggedEl.offsetTop + dTop}px`;

      // TODO(gs): attached callback doesn't seem to be called on appendChild.
      // https://github.com/webcomponents/webcomponentsjs/issues/18
      // TODO(gs): Make the ability fire an event instead. This class should just listen to the drop
      // event.
      if (DragDrop.lastDraggedEl.attachedCallback) {
        DragDrop.lastDraggedEl.attachedCallback();
      }
      DragDrop.dragEnd();
    }
  }

  class Rect extends Region {
    constructor() {
      super();
    }

    createdCallback() {
      super.createdCallback();
      this.createShadowRoot().appendChild(Utils.activateTemplate(template, doc));
    }
  }

  Abilities.of(Rect.prototype)
      .add(new FlexDroppable('droppable', new Key('d'), true));
  // TODO(gs)
  // $registry.add(EL_NAME, Abilities.config(Rect, {}, FlexDroppable).prototype);

  if (window['TEST_MODE']) {
    Rect.FlexDroppable = FlexDroppable;
  }

  return Rect;

});
</script>