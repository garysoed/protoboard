<base href="../..">

<link rel="import" href="out/ability/abilities.html">
<link rel="import" href="out/ability/droppable.html">
<link rel="import" href="out/check.html">
<link rel="import" href="out/di.html">
<link rel="import" href="out/region/region.html">
<link rel="import" href="out/service/move.html">
<link rel="import" href="out/trigger/key.html">
<link rel="import" href="out/utils.html">

<link rel="stylesheet" type="text/css" href="out/region/hand.css">

<template>
  <div id="root">
    <div id="content">
      <content></content>
    </div>
  </div>
</template>

<script>
DI
    .constant('doc', document.currentScript.ownerDocument)
    .with('template', doc => doc.querySelector('template'))
    .bind('pb_region_Hand', (
        $registry,
        Abilities,
        Check,
        Droppable,
        Key,
        Move,
        Region, 
        Utils, 
        doc, 
        template) => {

  /**
   * @class region.Hand
   * @extends region.Region
   */

  const EL_NAME = 'pb-r-hand';

  class ReorderableDroppable extends Droppable {
    constructor(name = 'pb-droppable', defaultTrigger = new Key('d'), defaultEnabled = true) {
      super(name, defaultTrigger, defaultEnabled);
    }

    trigger(el) {
      if (Check($(el).attr(this.attrName)).isBoolean().orThrows()) {
        let movedElement = Move.movedElements.values().next().value;
        if (movedElement) {
          // Go through every children and find the index that the element should be.
          let dropped = false;
          for (let child of Utils.toArray(el.children)) {
            let rect = child.getBoundingClientRect();
            if (!dropped && rect.left + rect.width / 2 > Move.mouseX) {
              dropped = true;
              el.insertBefore(movedElement, child);
            }
          }

          if (!dropped) {
            el.appendChild(movedElement);
          }
        }
      }
    }
  }

  class Hand extends Region {

    /**
     * Called when the element is created.
     *
     * @method createdCallback
     */
    createdCallback() {
      super.createdCallback();
      this.createShadowRoot()
          .appendChild(Utils.activateTemplate(template, doc));

      this.attachedCallback();
    }

    /**
     * Called when the element is attached to the document.
     *
     * @method attachedCallback
     */
    attachedCallback() {
      super.attachedCallback();
    }

    /**
     * Called when the element is detached from the document.
     *
     * @method detachedCallback
     */
    detachedCallback() {
      super.detachedCallback();
    }
  }


  Abilities.of(Hand.prototype)
      .add(new ReorderableDroppable('droppable', new Key('d'), true));
  $registry.add(EL_NAME, Hand.prototype);

  if (window['TEST_MODE']) {
    Hand.ReorderableDroppable = ReorderableDroppable;
  }

  return Hand;
});
</script>