<base href="..">
<script>
(() => {

// Private symbols.
const __function__ = Symbol();
const __localBindings__ = Symbol('localBindings');
const __name__ = Symbol();
const __parentScope__ = Symbol('parentScope');
const __resolvedValues__ = Symbol();
const __values__ = Symbol('values');

const FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
const SEPARATOR = '_';

class Provider {

  /**
   * @class DI.Provider
   * @constructor
   * @param {!Function} fn The function to run. The function's arguments will be bound based on
   *    their names.
   * @param {string} [name=null] Reference name of the provider. This is used for detecting cyclic
   *    dependencies.
   */
  constructor(fn, name = null) {
    this[__function__] = fn;
    this[__name__] = name;
    this[__resolvedValues__] = new Map();
  }

  /**
   * Resolves the provider. Resolved values are cached per scope.
   *
   * @method resolve
   * @param {!DI.Scope} scope The scope to resolve the value in.
   * @return {Object} The resolved value for the given scope.
   */
  resolve(scope) {
    if (!this[__resolvedValues__].has(scope)) {
      let argsString = this[__function__].toString().match(FN_ARGS)[1];
      let args = argsString ? argsString.split(',') : [];
      let resolvedArgs = args.map(arg => {
        let arg = arg.trim();

        // TODO(gs): Handle cyclic dependency.
        let value = scope.get(arg);

        if (value === undefined) {
          if (this[__name__]) {
            throw `Cannot find ${arg} while providing ${this[__name__]}`;
          } else {
            throw `Cannot find ${arg} while trying to run expression`;
          }
        } 

        return value;
      });

      let value = this[__function__].apply(null, resolvedArgs);

      if (value === undefined && this[__name__]) {
        console.warn(`Value of ${this[__name__]} is undefined`);
      }

      this[__resolvedValues__].set(scope, value);
    }

    return this[__resolvedValues__].get(scope);
  }
}

class BindingTree {

  /**
   * Represents a tree of bound values keyed by binding key.
   * @class DI.BindingTree
   * @constructor
   */
  constructor() {
    this[__values__] = new Map();
  }

  /**
   * Adds the given key and value to the tree. The tree will try to bind using the last segment of
   * the key. If this causes a conflict, it will create a subtree.
   *
   * @method add
   * @param {string} key The key to bind the value to.
   * @param {Object} value The value to be bound.
   * @param {number} [depth = 0] The depth of the key to use as binding key. This should not be
   *    called from outside the class.
   */
  add(key, value, depth = 0) {
    let segments = key.split(SEPARATOR);
    let bindingKey = segments[segments.length - 1 - depth];

    if (!this[__values__].has(bindingKey)) {
      this[__values__].set(bindingKey, {
        key: key,
        value: value
      });
    } else {
      // There is already a value corresponding to this key
      let existingValue = this[__values__].get(bindingKey);
      if (existingValue.key === key) {
        throw `Key ${key} is already bound`;
      }

      let newTree = new BindingTree();
      this[__values__].set(bindingKey, newTree);
      newTree.add(existingValue.key, existingValue.value, depth + 1);
      newTree.add(key, value, depth + 1);
    }
  }

  /**
   * Returns the value corresponding to the given key.
   *
   * @param {string} key Key of the value to return.
   * @param {number} [depth=0] The depth of the key to use as binding key. This should not be
   *    called from outside the class.
   * @return {*} The bound value, or undefined if the value cannot be found, or if the key has
   *    collision but collision cannot be resolved.
   */
  get(key, depth = 0) {
    let segments = key.split(SEPARATOR);
    let bindingKey = segments[segments.length - 1 - depth];

    if (bindingKey === undefined) {
      return undefined;
    }

    if (!this[__values__].has(bindingKey)) {
      return undefined;
    }

    let value = this[__values__].get(bindingKey);
    if (value instanceof BindingTree) {
      return value.get(key, depth + 1);
    } else {
      return value.value;
    }
  }
}

class Scope {
  /**
   * Scope containing local bindings.
   * 
   * @class DI.Scope
   * @constructor
   * @param {DI.Scope} [parentScope=null] The parent scope.
   */
  constructor(parentScope = null) {
    this[__localBindings__] = new BindingTree();
    this[__parentScope__] = parentScope;
  }

  /**
   * Creates a new child scope with the given value bound to the given key in its local binding.
   *
   * @method with
   * @param {string} key The key to bound the value to.
   * @param {!Function} fn The function to run. The function's arguments will be bound based on
   *    their names.
   * @return {!DI.Scope} The newly created child scope.
   */
  with(key, value) {
    let childScope = new Scope(this);
    childScope[__localBindings__].add(key, new Provider(value, key));
    return childScope;
  }

  /**
   * Globally binds the given value to the given key.
   *
   * @method bind
   * @param {string} key The key to bound the value to.
   * @param {!Function} fn The function to run. The function's arguments will be bound based on
   *    their names.
   * @return {[type]} [description]
   */
  bind(key, value) {
    bindings.add(key, new Provider(value, key));
  }

  /**
   * Returns the provider bound to the given key and resolve it in this scope. This will first check
   * for the local bindings, then its ancestors. If no binding is found in the ancestral path, this
   * will check for the global bindings.
   *
   * @method get
   * @param {string} key Key whose bound value should be returned.
   * @return {*} The value bound to the given key, or undefined if no values can be found.
   */
  get(key) {
    let provider = this[__localBindings__].get(key);
    if (provider === undefined) {
      if (this[__parentScope__]) {
        return this[__parentScope__].get(key);
      } else {
        let globalProvider = bindings.get(key);
        if (globalProvider === undefined) {
          return undefined;
        } else {
          return globalProvider.resolve(this);
        }
      }
    } else {
      return provider.resolve(this);
    }
  }

  run(fn) {
    new Provider(fn).resolve(this);
  }
}

const bindings = new BindingTree();

const DI = new Scope();
window['DI'] = DI;

if (window['TEST_MODE']) {
  DI.Scope = Scope;
  DI.BindingTree = BindingTree;
  DI.Provider = Provider;
  DI.bindings = bindings;
}

})();
</script>